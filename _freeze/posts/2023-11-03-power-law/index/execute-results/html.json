{
  "hash": "83b9c7320f5a7feb12e297d002848f0b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Power laws on log-linear plots\"\nauthor: \"Andrew MacDonald, Amélie Morin\"\ndescription: |\n  How to fit and plot Power Law curves with lm.\ndate: 03 Nov 2023\neditor: source\ncategories: [UdeS, stan]\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n## The backgroung\n\nPower laws are very common in ecology. \nOne reason for this is surely how easy it is to fit and plot. \nThere are also many reasons based on theory, for example famous work on metabolic scaling.\n\n## The Math\n\n\"Power law\" is just a fancy name for a polynomial with an exponent between 0 and 1. This gives a declerating curve (figure below)\n\nPower laws look like this:\n\n$$\ny = ax^b\n$$\n\nIt becomes linear if you log both sides, like this:\n\n$$ \n\\ln{y} = \\ln{a} + b\\ln{x}\n$$\n\nThis is a format we can fit with our favourite linear OLS function, `lm()`.\n\n## Simulate data\n\nWe're simulating data here to roughly imitate a dataset on bumblebees collected by [Amélie Morin](https://www.fournierlab.com/eacutequipe.html) from Université Laval.\n\nThis is a very simplified look at only one part of the dataset. \nHere we are asking if there are more bumblebees in longer strips of habitat. The independent variable is the length of the strip, in meters. \nThe response is the observed counts of bumblebees.\n\nWe begin by picking parameter values and a range of simulated X variables \n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 11\nb <- 0.3\n# longeur <- runif(104, min = 2, max = 25)\nlongeur <- sample(c(2:7, 10, 12, 15, 25), size = 104, replace = TRUE)\n\nmoy_bourdons <- a * longeur ^b\n\nplot(longeur, moy_bourdons)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\nWe simulate observations of counts using a Poisson distribution, so that the data resemble biological reality.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobs_bourdons <- rpois(104, lambda = moy_bourdons)\n\n\ntibble(longeur, obs_bourdons) |> \n  ggplot(aes(x = longeur, y = obs_bourdons)) + \n  geom_count()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n:::{.callout-note}\nHere we are using a model which is similar to, but not identical to, the model we used to generate the data. That is to emphasize that while this technique (i.e. a linear model on log-transformed data) is not perfect, it still gets very close and is a great solution in many cases.\n:::\n\n## Fit a power law\n\nWe fit the model by log-transforming and then fitting a straightforward linear model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbourdon_data <- tibble(longeur, obs_bourdons)\n\nbourdon_data_log <- bourdon_data |> \n  mutate(log_longeur = log(longeur),\n         log_obs_bourdons = log(obs_bourdons))\n\n\nlm_pwr <- lm(log_obs_bourdons ~ log_longeur, data = bourdon_data_log)\n```\n:::\n\n\n## Predict\n\nTo draw a line and confidence intervals we make predictions. \nHowever these are NOT predictions on the original data, but on a nice even sequence of values on the x-axis.  \nA few points to note here:\n\n* I take a range of x-values and then log-transform them, then transform them back. This imitates the same process that we went throught with the actual data\n* I'm using `broom::augment` from the `broom` package. It is awesome! It takes a model and a dataset, and adds the prediction to the dataset as a new set of columns. See `?broom::augment` for all the details.\n* Once we have the predictions, we need to back-transform everything by exponentiating with `exp()`: the average response (`.fitted`), the lower and upper confidence intervals (`.lower` and `.upper`) and of course the x-axis values. Here i use a little function from the tidyverse to apply `exp()` to all columns at once. Learn more by typing `vignette(\"colwise\")`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_data <- tibble(log_longeur = log(1:25))\n\npredictions_pwr <- broom::augment(x = lm_pwr,\n                                  newdata = new_data,\n                                  interval = \"confidence\") |>\n  mutate(across(everything(), exp))\n```\n:::\n\n\n\n\n## Plot\n\nFinally we plot the transformed predictions using ggplot2:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npredictions_pwr |> \n  ggplot(aes(x = log_longeur, y = .fitted)) + \n  geom_ribbon(\n    aes(x = log_longeur,\n        ymin = .lower,\n        ymax = .upper), \n    inherit.aes = FALSE, fill = \"lightgreen\") + \n  geom_line() + \n  geom_count(aes(x = longeur, y = obs_bourdons), data = bourdon_data) + \n  geom_vline(xintercept = 12, lty = 2, col = \"red\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}