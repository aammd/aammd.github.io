{
  "hash": "2c6e4f3c0a11fa4874aa9feeb4bd245f",
  "result": {
    "markdown": "---\ntitle: \"Including measurement uncertainty\"\nauthor: \"Andrew MacDonald\"\ndescription: |\n  Sometimes we have slightly-known knowns.\ndate: 11 Nov 2022\neditor: source\ncategories: [UdeS, stan]\ndraft: true\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(targets)\nlibrary(ggplot2)\nlibrary(tidyverse)\nlibrary(tidybayes)\nlibrary(cmdstanr)\n```\n:::\n\n\n## Two ways of thinking about measurement error\n\n* repeat independent measures of your predictor variable\n* standard error of the x variables \n\nlet's simulate each\n\n\n## repeated measures of your predictor\n\n\nPhotosynthesis is often limited by phosphorous -- more P, more chlorophyll in lake water.\nlet's say you're measuring phosphorous in lakes. For each lake you have one measure of primary productivity (chlorophyll concentration) and 5 measures of phosphorous (from water samples). \nThe P actually causes the chlorophyll -- but the _true_ average P concentration also causes the measurements we are making!\n\n\n::: {.cell}\n\n```{.r .cell-code}\navg_chl <- 60\nchl_per_P <- 5\nsd_chl <- 3\nsd_P <- .7\n\nchl_p <- tibble(Phos = seq(from = -1, to = 5, length.out = 25), \n       chl = rnorm(n = 25, mean = avg_chl + chl_per_P * Phos, sd = sd_chl),\n       P_meas = map(Phos, ~ rnorm(n = 5, mean = .x, sd = sd_P)))\n\nchl_p  |> \n  unnest(P_meas) |> \n  ggplot(aes(x = P_meas, y = chl)) + geom_point()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrepeat_measures <- cmdstanr::cmdstan_model(\n  here::here(\"posts/2023-09-01-measurement-error/repeat_measures.stan\"),\n  pedantic = TRUE)\nrepeat_measures\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\ndata {\n  int n;\n  array[n] vector[5] P;\n  vector[n] chl;\n}\nparameters {\n  real intercept;\n  real slope;\n  real<lower=0> sd_chl;\n  real<lower=0> sd_P;\n  vector[n] true_P;\n}\nmodel {\n  intercept ~ normal(60, 5);\n  slope ~ normal(5, 2);\n  sd_chl ~ exponential(.5);\n  sd_chl ~ exponential(1);\n  for (i in 1:n){\n    P[i] ~ normal(true_P[i], sd_P);\n  }\n  chl ~ normal(true_P, sd_chl);\n}\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrepeat_measures_post <- repeat_measures$sample(\n  data = list(\n    n = 25, \n    P = chl_p$P_meas,\n    chl = chl_p$chl\n  ),refresh = 0L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 4 sequential chains...\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 1 Informational Message: The current Metropolis proposal is about to be rejected because of the following issue:\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 1 Exception: normal_lpdf: Scale parameter is 0, but must be positive! (in '/var/folders/x7/l08zn2396g797m5ws54np_6w0000gp/T/Rtmp64qJKx/model-190ace66dd7.stan', line 19, column 4 to column 35)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 1 If this warning occurs sporadically, such as for highly constrained variable types like covariance matrices, then the sampler is fine,\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 1 but if this warning occurs often then your model may be either severely ill-conditioned or misspecified.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 1 \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nChain 1 finished in 0.5 seconds.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 2 Informational Message: The current Metropolis proposal is about to be rejected because of the following issue:\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 2 Exception: normal_lpdf: Scale parameter is 0, but must be positive! (in '/var/folders/x7/l08zn2396g797m5ws54np_6w0000gp/T/Rtmp64qJKx/model-190ace66dd7.stan', line 19, column 4 to column 35)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 2 If this warning occurs sporadically, such as for highly constrained variable types like covariance matrices, then the sampler is fine,\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 2 but if this warning occurs often then your model may be either severely ill-conditioned or misspecified.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 2 \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nChain 2 finished in 0.2 seconds.\nChain 3 finished in 0.2 seconds.\nChain 4 finished in 0.3 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.3 seconds.\nTotal execution time: 1.7 seconds.\n```\n:::\n:::\n\n\nplot the line\n\nplot the intervals for the two slope parameters\n\nplot the true P values\n\n## using SD and mean values\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsd_mean_only <- cmdstanr::cmdstan_model(\n  here::here(\"posts/2023-09-01-measurement-error/sd_mean_only.stan\"), pedantic = TRUE)\nsd_mean_only\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\ndata {\n  int n;\n  // array[n] vector[5] P;\n  vector[n] P_sds;\n  vector[n] P_means;\n  vector[n] chl;\n}\nparameters {\n  real intercept;\n  real slope;\n  real<lower=0> sd_chl;\n  vector[n] true_P;\n}\nmodel {\n  intercept ~ normal(60, 5);\n  slope ~ normal(5, 2);\n  sd_chl ~ exponential(1);\n  true_P ~ normal(P_means, P_sds);\n  chl ~ normal(true_P, sd_chl);\n}\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsd_mean_only_post <- sd_mean_only$sample(\n  data = list(\n    n = 25, \n    P_sds = map_dbl(chl_p$P_meas, sd),\n    P_means = map_dbl(chl_p$P_meas, sd),\n    chl = chl_p$chl\n  ),refresh = 0L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 4 sequential chains...\n\nChain 1 finished in 0.1 seconds.\nChain 2 finished in 0.2 seconds.\nChain 3 finished in 0.1 seconds.\nChain 4 finished in 0.1 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.1 seconds.\nTotal execution time: 0.7 seconds.\n```\n:::\n:::\n\n::: {#fig-compare .cell layout-nrow=\"2\"}\n\n```{.r .cell-code}\nsd_mean_only_post$draws() |> \n  bayesplot::mcmc_areas(c(\"intercept\", \"slope\")) + \n  labs(title = \"from means and sd\")\n\n\nrepeat_measures_post$draws() |> \n  bayesplot::mcmc_areas(c(\"intercept\", \"slope\")) + \n  labs(title = \"from repeated measures\")\n```\n\n::: {.cell-output-display}\n![using means and SDs](index_files/figure-html/fig-compare-1.png){#fig-compare-1 width=672}\n:::\n\n::: {.cell-output-display}\n![using repeated measurements](index_files/figure-html/fig-compare-2.png){#fig-compare-2 width=672}\n:::\n\nThe posterior distribution for the parameters is the same both ways\n:::\n\n\n\n## comparing inference from the two\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}