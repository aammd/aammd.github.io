{
  "hash": "2ff0180614bf99f7150699f39913acfe",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"How to model discrete growth\"\nauthor: \"Andrew MacDonald\"\ndescription: |\n  Comparing a lagged AR-1 model with the marginalized transition distribution.\ndate: 24 Nov 2023\neditor: source\ncategories: [UdeS, stan, reproduction, MAR]\nknitr:\n  opts_chunk: \n    warning: false\n    message: false\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(cmdstanr)\nlibrary(ggplot2)\nlibrary(tidyverse)\nlibrary(tidybayes)\nlibrary(targets)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_load(one_time)\nplot(one_time, type = \"l\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n\n## Controversy! \n\n## \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load the model in stan\ntransition <- cmdstan_model(here::here(\"posts/2023-11-24-how-to-model-growth/ar1.stan\"))\n\ntransition\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.stan}\ndata{\n  int n;\n  vector[n] time;\n  vector[n] x;\n}\n// transformed data {\n//   vector[n] x = log(pop);\n// }\nparameters {\n  real<lower=0> a;\n  real<lower=0,upper=1> b;\n  real<lower=0> sigma;\n}\ntransformed parameters {\n  real mu_max = a / (1 - b);\n  real sigma_max = sigma /sqrt(1 - b^2);\n}\nmodel {\n  a ~ normal(2, .5);\n  b ~ beta(5,2);\n  sigma ~ exponential(5);\n  x ~ normal(\n    mu_max .* (1 - pow(b, time)),\n    sigma_max .* sqrt(1 - pow(b^2, time))\n    );\n}\ngenerated quantities {\n  vector[15] x_pred;\n  x_pred[1] = 0;\n  for (j in 1:14) {\n    x_pred[j+1] = normal_rng(\n      mu_max * (1 - pow(b, j)),\n      sigma_max * sqrt(1 - pow(b^2, j))\n      );\n  }\n}\n```\n\n\n:::\n:::\n\n\nHere is another approach, using a lagged population growth model\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load the model in stan\nlagged_growth <- cmdstan_model(here::here(\"posts/2023-11-24-how-to-model-growth/multiple_spp_ar1.stan\"))\n\nlagged_growth\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ndata {\n  int n;\n  int nclone;\n  vector[n] x;\n  array[n] int<lower=1, upper=nclone> clone_id;\n  // for predictions\n  int<lower=0, upper=1> fit;\n  int nyear;\n}\ntransformed data {\n  array[n - nclone] int time;\n  array[n - nclone] int time_m1;\n  for (i in 2:n) {\n    if (clone_id[i] == clone_id[i-1]) {\n      time[i - clone_id[i]] = i;\n      time_m1[i - clone_id[i]] = i - 1;\n    }\n  }\n}\nparameters {\n  real<lower=0> a;\n  real<lower=0,upper=1> b;\n  real<lower=0> sigma;\n}\nmodel {\n\n  a ~ normal(2, .5);\n  b ~ beta(5,2);\n  sigma ~ exponential(5);\n\n  if (fit == 1) {\n\n    x[time] ~ normal(\n      a + b * x[time_m1],\n      sigma);\n  }\n}\ngenerated quantities {\n  vector[nyear] x_pred;\n\n  x_pred[1] = 0;\n\n  for (j in 2:nyear){\n    x_pred[j] =  a + b * x_pred[j-1] + normal_rng(0, sigma);\n  }\n}\n```\n\n\n:::\n:::\n\n\n## Simulations\n\nHere are simulations from a one-species AR-1 model that imitate Ives et al. figure 1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimulate_pop_growth <- function(\n    a = 0, \n    b, \n    sigma = 1, \n    tmax = 50, \n    x0 = -8) {\n  \n  xvec <- numeric(tmax)\n  \n  xvec[1] <- x0\n  \n  ## process error\n  eta <- rnorm(tmax, mean = 0, sd = sigma)\n  \n  for(time in 2:tmax){\n    xvec[time] <- a + b*xvec[time-1] + eta[time]\n  }\n  \n  return(xvec)\n}\n```\n:::\n\n\nI'm going to simulate a modest number of time series, and choose parameters to make the time series slightly resemble the aphid experiment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na_fig = 1\nb_fig = .8\nsigma_fig = .7\n\nts_data <- map_dfr(1:12, \n        ~ tibble(\n          pop = simulate_pop_growth(\n            a = a_fig, \n            b = b_fig,\n            tmax = 16, \n            sigma = sigma_fig, \n            x0 = 0\n            ),\n          time = 0:(length(pop)-1)\n        ),\n        .id = \"sim\"\n)\n\nts_data |> \n  ggplot(aes(x =time, y = pop, group = sim)) + \n  geom_line()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nknitr::kable(head(ts_data))\n```\n\n::: {.cell-output-display}\n\n\n|sim |       pop| time|\n|:---|---------:|----:|\n|1   | 0.0000000|    0|\n|1   | 0.9548568|    1|\n|1   | 2.8629644|    2|\n|1   | 2.8740721|    3|\n|1   | 2.5695696|    4|\n|1   | 3.2455612|    5|\n\n\n:::\n:::\n\n\n\n## Transition distribution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nts_data_nozero <- filter(ts_data, time != 0)\n\n\ntransition_sample <- transition$sample(\n  data = list(n = nrow(ts_data_nozero),\n              x = ts_data_nozero$pop,\n              time = ts_data_nozero$time),\n  parallel_chains = 4, refresh = 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRunning MCMC with 4 parallel chains...\n\nChain 1 finished in 1.7 seconds.\nChain 3 finished in 1.7 seconds.\nChain 2 finished in 1.8 seconds.\nChain 4 finished in 1.7 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 1.7 seconds.\nTotal execution time: 2.0 seconds.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntransition_sample |> \n  spread_rvars(x_pred[time]) |> \n  ggplot(aes(x = time-1, ydist = x_pred)) + \n  stat_lineribbon() + \n  scale_fill_brewer(palette = \"Greens\", direction = -1) + \n  theme_bw() + \n  geom_line(aes(x = time, y = pop, group = sim),\n            inherit.aes = FALSE, data = ts_data) + \n  labs(x = \"Time\", y = \"log population size\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntransition_sample |>\n  gather_rvars(a, b, sigma) |> \n  ggplot(aes(y = .variable, dist = .value)) + \n  stat_halfeye() + \n  geom_point(\n    aes(y = .variable,  x = .value),\n    inherit.aes = FALSE,\n    data = tribble(\n      ~ .variable, ~.value,\n      \"a\", a_fig, \n      \"b\", b_fig,\n      \"sigma\", sigma_fig), col = \"red\", size = 2) \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n## Lagged model\n\nThis time there is no need to drop 0s\n\n\n::: {.cell}\n\n```{.r .cell-code}\nts_data <- ts_data |> \n  mutate(sim = readr::parse_number(sim))\n\nlagged_growth_sample <- lagged_growth$sample(\n  data = list(n = nrow(ts_data),\n              nclone = max(ts_data$sim),\n              x = ts_data$pop,\n              time = ts_data$time,\n              clone_id = ts_data$sim,\n              fit = 1,\n              nyear = 15),\n  parallel_chains = 4, refresh = 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRunning MCMC with 4 parallel chains...\n\nChain 1 finished in 0.3 seconds.\nChain 2 finished in 0.3 seconds.\nChain 3 finished in 0.3 seconds.\nChain 4 finished in 0.3 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.3 seconds.\nTotal execution time: 0.5 seconds.\n```\n\n\n:::\n:::\n\n\n\n### predictions \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlagged_growth_sample |> \n  spread_rvars(x_pred[time]) |> \n  ggplot(aes(x = time-1, ydist = x_pred)) + \n  stat_lineribbon() + \n  scale_fill_brewer(palette = \"Greens\", direction = -1) + \n  theme_bw() + \n  geom_line(aes(x = time, y = pop, group = sim),\n            inherit.aes = FALSE, data = ts_data) + \n  labs(x = \"Time\", y = \"log population size\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n### parameters\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlagged_growth_sample |>\n  gather_rvars(a, b, sigma) |> \n  ggplot(aes(y = .variable, dist = .value)) + \n  stat_halfeye() + \n  geom_point(\n    aes(y = .variable,  x = .value),\n    inherit.aes = FALSE,\n    data = tribble(\n      ~ .variable, ~.value,\n      \"a\", a_fig, \n      \"b\", b_fig,\n      \"sigma\", sigma_fig), col = \"red\", size = 2) \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}