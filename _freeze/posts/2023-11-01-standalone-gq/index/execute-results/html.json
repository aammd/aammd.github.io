{
  "hash": "cb044be8c490e4432d032f04da7b5fb2",
  "result": {
    "markdown": "---\ntitle: \"Stan-dalone generated quantites\"\nauthor: \"Andrew MacDonald\"\ndescription: |\n  working with Stan after you've done that once already.\ndate: 11 Nov 2022\neditor: source\ncategories: [UdeS, stan, generated quantities]\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(cmdstanr)\nlibrary(ggplot2)\nlibrary(tidyverse)\nlibrary(tidybayes)\n```\n:::\n\n\n## Breaking apart Stan programs\n\nSometimes we don't want the output of a Stan model to become enormous. \nHowever, Stan models can be very convenient for calculating `generated quantities`. \nOf course this can be done in R, but sometimes it is just easier to have all the outputs presented in the same way.\n\nSee a description of this in the [User's guide](https://mc-stan.org/docs/cmdstan-guide/standalone-generate-quantities.html) and in the [CmdStanR help file](https://mc-stan.org/cmdstanr/reference/model-method-generate-quantities.html)\n\n\n## example: Marginal effects in multiple regression\n\nSuppose there is a plant which, when growing in N-rich soil, is able to generate chemical defenses to prevent damage by a herbivorous insect. On poor soil the herbivore eats much more of the plant\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(4812)\nsoil_quality <- runif(200, min = -3, max = 3)\ninsect_biomass <- runif(200, min = -10, max = 10)\n# each gram of insect biomass eats 1.2 grams of plant biomass\ninsect_eff_per_g <- 2\n\nsoil_quality_eff_per_unit <- 0\n\nsoil_quality_on_herb <- -.5\n\nherb_avg_soil_avg_density <- 33\n\nmu_herbivory <- herb_avg_soil_avg_density + \n  soil_quality_eff_per_unit* soil_quality + \n  (insect_eff_per_g + soil_quality_on_herb*soil_quality) * insect_biomass \n\nsigma_herb <- 5\nobs_herbivory <- rnorm(n = 200, mu_herbivory, sigma_herb)\n\ntibble(soil_quality, insect_biomass, obs_herbivory) |> \n  ggplot(aes(x = soil_quality, y = obs_herbivory, col = insect_biomass)) + \n  geom_point()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\nHere is a Stan program to model this interaction\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# class-output: stan\n\nmultiple_regression <- cmdstan_model(\n  here::here(\n    \"posts/2023-11-01-standalone-gq/multiple_regression.stan\"\n    ))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nIn file included from stan/src/stan/model/model_header.hpp:11:\nstan/src/stan/model/model_base_crtp.hpp:198: warning: 'void stan::model::model_base_crtp<M>::write_array(boost::random::ecuyer1988&, std::vector<double, std::allocator<double> >&, std::vector<int>&, std::vector<double, std::allocator<double> >&, bool, bool, std::ostream*) const [with M = multiple_regression_model_namespace::multiple_regression_model; boost::random::ecuyer1988 = boost::random::additive_combine_engine<boost::random::linear_congruential_engine<unsigned int, 40014, 0, 2147483563>, boost::random::linear_congruential_engine<unsigned int, 40692, 0, 2147483399> >; std::ostream = std::basic_ostream<char>]' was hidden [-Woverloaded-virtual=]\n  198 |   void write_array(boost::ecuyer1988& rng, std::vector<double>& theta,\n      | \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nC:/Users/UTILIS~1/AppData/Local/Temp/RtmpCWWESL/model-25ec8287909.hpp:419: note:   by 'multiple_regression_model_namespace::multiple_regression_model::write_array'\n  419 |   write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&\n      | \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nstan/src/stan/model/model_base_crtp.hpp:136: warning: 'void stan::model::model_base_crtp<M>::write_array(boost::random::ecuyer1988&, Eigen::VectorXd&, Eigen::VectorXd&, bool, bool, std::ostream*) const [with M = multiple_regression_model_namespace::multiple_regression_model; boost::random::ecuyer1988 = boost::random::additive_combine_engine<boost::random::linear_congruential_engine<unsigned int, 40014, 0, 2147483563>, boost::random::linear_congruential_engine<unsigned int, 40692, 0, 2147483399> >; Eigen::VectorXd = Eigen::Matrix<double, -1, 1>; std::ostream = std::basic_ostream<char>]' was hidden [-Woverloaded-virtual=]\n  136 |   void write_array(boost::ecuyer1988& rng, Eigen::VectorXd& theta,\n      | \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nC:/Users/UTILIS~1/AppData/Local/Temp/RtmpCWWESL/model-25ec8287909.hpp:419: note:   by 'multiple_regression_model_namespace::multiple_regression_model::write_array'\n  419 |   write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&\n      | \n```\n:::\n\n```{.r .cell-code}\nmultiple_regression\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndata{\n  int<lower=0> n;\n  vector[n] soil;\n  vector[n] insects;\n  vector[n] herbivory;\n}\nparameters{\n  real avg_herb;\n  vector[3] beta;\n  real<lower=0> sigma;\n}\nmodel{\n  sigma ~ exponential(.25);\n  beta ~ std_normal();\n  avg_herb ~ normal(30, 5);\n  herbivory ~ normal(avg_herb + beta[1]* soil + beta[2]*insects + beta[3]*(soil .* insects), sigma);\n}\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmultiple_post <- multiple_regression$sample(data = list(n = length(soil_quality), soil = soil_quality, insects = insect_biomass, herbivory = obs_herbivory), parallel_chains = 2, refresh = 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 4 chains, at most 2 in parallel...\n\nChain 1 finished in 0.3 seconds.\nChain 2 finished in 0.3 seconds.\nChain 3 finished in 0.3 seconds.\nChain 4 finished in 0.3 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.3 seconds.\nTotal execution time: 0.9 seconds.\n```\n:::\n:::\n\n\nWe can see that the posteriors are close to the true values (not the point of this post, but always good to check)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmultiple_post$summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 10\n  variable     mean   median     sd    mad       q5      q95  rhat ess_bulk\n  <chr>       <num>    <num>  <num>  <num>    <num>    <num> <num>    <num>\n1 lp__     -415.    -415.    1.54   1.41   -418.    -413.     1.00    2186.\n2 avg_herb   32.9     32.9   0.335  0.338    32.4     33.5    1.00    4607.\n3 beta[1]     0.190    0.193 0.190  0.193    -0.129    0.499  1.00    4774.\n4 beta[2]     1.93     1.93  0.0572 0.0575    1.84     2.03   1.00    4286.\n5 beta[3]    -0.474   -0.473 0.0329 0.0332   -0.527   -0.420  1.00    4479.\n6 sigma       4.80     4.79  0.240  0.243     4.43     5.22   1.00    4685.\n# ℹ 1 more variable: ess_tail <num>\n```\n:::\n:::\n\n\nNow suppose we want to plot this interaction. We could do so in R, no problem. We could also do that in the model above. But you might not want to! reasons include:\n\n* keeping the output of any one model small(ish) so that you can actually work with it\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# class-output: stan\n\nmulti_reg_triptych <- cmdstan_model(\n  here::here(\n    \"posts/2023-11-01-standalone-gq/multi_reg_triptych.stan\"\n    ))\n\nmulti_reg_triptych\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndata {\n  int<lower=0> npred;\n  vector[npred] new_soil;\n  vector[npred] new_insect;\n}\n// copied from the previous model!\nparameters{\n  real avg_herb;\n  vector[3] beta;\n  real<lower=0> sigma;\n}\ngenerated quantities {\n  vector[npred] pred_herbivory;\n  for (i in 1:npred){\n    pred_herbivory[i] = normal_rng(avg_herb + beta[1]* new_soil[i] + beta[2]*new_insect[i] + beta[3]*(new_soil[i] * new_insect[i]), sigma);\n  }\n}\n```\n:::\n:::\n\n\nget the prediction data ready\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnewdata <- expand_grid(new_insect = c(-5, 0, 5),\n            new_soil = seq(from = -10, to = 10, length.out = 11))\n\n\nmulti_trip <- multi_reg_triptych$generate_quantities(\n  fitted_params = multiple_post,\n  data = list(\n    new_insect = newdata$new_insect,\n    new_soil = newdata$new_soil,\n    npred = nrow(newdata)\n  )\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning standalone generated quantities after 4 MCMC chains, 1 chain at a time ...\n\nChain 1 finished in 0.0 seconds.\nChain 2 finished in 0.0 seconds.\nChain 3 finished in 0.0 seconds.\nChain 4 finished in 0.0 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.0 seconds.\nTotal execution time: 1.0 seconds.\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmulti_trip |> \n  gather_rvars(pred_herbivory[i]) |> \n  bind_cols(newdata) |> \n  ggplot(aes(x = new_soil, dist = .value)) + \n  stat_lineribbon() + \n  facet_wrap(~new_insect) + \n  scale_fill_brewer(palette = \"Greens\", direction = -1) + \n  labs(x = \"new_soil\", y = \"predicted herbivory\")\n```\n\n::: {.cell-output-display}\n![Visualizing an interaction. The effect of soil quality on herbivory varies with herbivore biomass (in a very pretend, make-believe example).](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}