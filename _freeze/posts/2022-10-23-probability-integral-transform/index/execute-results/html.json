{
  "hash": "06484918aa318518a17913fc896ab544",
  "result": {
    "markdown": "---\ntitle: \"Probability integral transforms\"\ndescription: |\n  Understanding a diagnostic tool for models.\nauthor: \"Andrew\"\ndate: 23 Oct 2022\nimage: PIT_when_wrong-1.png\nbibliography: references.bib\ndraft: false\n---\n\n\n::: callout-tip\nThis is not a review or a proof of the Probability Integral Transform. A grad student asked me \"what is this and why does it work\" and I wanted to explore it with them.\n:::\n\nAmong the many wonderful plots that you can make with `bayesplot`, you will find one called [`ppc_loo_pit_overlay`](https://mc-stan.org/bayesplot/reference/PPC-loo.html). You can read a lot more about it in this fabulous paper on [Visualisation in Bayesian Workflow](https://rss.onlinelibrary.wiley.com/doi/full/10.1111/rssa.12378) [@gabry2019]\n\nSo what is it, and how does it work?\n\n## Exploring with simulation\n\n\nTake random numbers from a distribution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsome_numbers <- rnorm(1560, mean = 14, sd = 2.5)\nhist(some_numbers)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\nThen run them through that distribution's CDF\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsome_pit <- pnorm(some_numbers, mean = 14, sd = 2.5)\nhist(some_pit)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nSure enough we get a uniform shape!\n\n## What happens when you are wrong\n\nlet's make some curves that don't really match\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nn <- 4000\ntibble(meanval = seq(from = 1, to = 14, length.out = 6),\n       sd = 2.5) |> \n  expand_grid(x = seq(from = 0, to = 18, length.out = 30)) |>\n  mutate(normal_dist = dnorm(x, mean = meanval, sd = sd),\n         gamma_dist = dgamma(x, \n                        shape = meanval^2/sd^2,\n                        rate = meanval/sd^2)) |> \n  pivot_longer(ends_with(\"dist\"), \n               names_to = \"distribution\",\n               values_to = \"value\") |> \n  ggplot(aes(x = x, y = value, colour = distribution)) + \n  geom_line()  +\n  facet_wrap(~meanval)\n```\n\n::: {.cell-output-display}\n![](unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nWe can see that the fit gets worse as the mean drops\n\nlet's simulate data from the gamma and use the PIT assuming instead it is normal:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 4000\ntibble(meanval = seq(from = 1, to = 14, length.out = 6),\n       sd = 2.5) |> \n  rowwise() |>\n  mutate(normal_dist = list(rnorm(n, mean = meanval, sd = sd)),\n         gamma_dist = list(rgamma(n, \n                        shape = meanval^2/sd^2,\n                        rate = meanval/sd^2))) |> \n  pivot_longer(ends_with(\"dist\"), \n               names_to = \"distribution\",\n               values_to = \"samples\") |> \n  rowwise() |> \n  mutate(pit_samples = list(pnorm(samples, mean = meanval, sd = sd))) |> \n  select(-samples) |> \n  # filter(distribution == \"gamma_dist\") |> \n  unnest(pit_samples) |> \n  ggplot(aes(x = pit_samples)) + \n  geom_histogram() + \n  facet_grid(distribution~meanval)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nlet's try it with just the gamma, but changing both moments and always using the normal:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 4000\nexpand_grid(meanval = seq(from = 1, to = 14, length.out = 6),\n       sdval = seq(from = .2, to = 7, length.out = 4)) |> \n  rowwise() |>\n  mutate(gamma_dist = list(rgamma(n, \n                        shape = meanval^2/sdval^2,\n                        rate = meanval/sdval^2))) |> \n  rowwise() |> \n  mutate(pit_samples = list(\n    pnorm(gamma_dist,\n          mean = meanval,\n          sd = sdval))) |> \n  select(-gamma_dist) |> \n  # filter(distribution == \"gamma_dist\") |> \n  unnest(pit_samples) |> \n  ggplot(aes(x = pit_samples)) + \n  geom_histogram() + \n  facet_grid(sdval~meanval)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nand with the lognormal\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 4000\nexpand_grid(meanval = seq(from = 1, \n                          to = 14, \n                          length.out = 6),\n       sdval = seq(from = .2, \n                   to = 7, \n                   length.out = 4)) |> \n  rowwise() |>\n  mutate(\n    cf = log(sdval/meanval)^2 + 1,\n    lnorm_dist = list(rlnorm(n, \n                        meanlog = log(meanval) - .5*cf, \n                        sdlog = sqrt(cf))\n                      )\n    )|> \n  rowwise() |> \n  mutate(pit_samples = list(\n    pnorm(lnorm_dist,\n          mean = meanval,\n          sd = sdval)\n    # plnorm(lnorm_dist, \n    #        meanlog = log(meanval) - .5*cf, \n    #        sdlog = sqrt(cf))\n    )) |> \n  select(-lnorm_dist) |> \n  # filter(distribution == \"gamma_dist\") |> \n  unnest(pit_samples) |> \n  ggplot(aes(x = pit_samples)) + \n  geom_histogram() + \n  facet_grid(sdval~meanval)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](PIT_when_wrong-1.png){width=672}\n:::\n:::\n\n\n## What did we learn here\n\nThe PIT is one of an arsenal of diagnostic tools. The idea here is to run data \"backwards\" through the distribution we've chosen. If the distribution we chose is something like realize, the result should look kind of flat. If we are very far wrong, it won't be flat. So this can serve as a quick goodness-of-fit test for your response distribution\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}