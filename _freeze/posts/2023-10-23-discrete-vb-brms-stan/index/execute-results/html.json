{
  "hash": "3b3e4ad163718ab5605d98847c8ab14d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Modelling discrete growth\"\nauthor: \"Andrew MacDonald, Kelly Forester\"\ndescription: |\n  How to model the growth of things in a sensible fashion\ndate: 7 Nov 2023\neditor: source\ncategories: [UdeS, stan]\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(brms)\nlibrary(ggplot2)\nlibrary(tidyverse)\nlibrary(tidybayes)\nlibrary(cmdstanr)\n```\n:::\n\n\n##  growing things get bigger\n\nAnimals get bigger over time, and young change in size faster than more mature individuals. \nThe classic Von Bertanaffy growth equation has animals growing from a starting size to a final asymptotic size:\n\n$$\nL_t = L_0e^{-rt} + L_{max}(1 - e^{-rt})\n$$\n\n* $L_0$ is the starting size\n* $L_{max}$ is the final size\n* $r$ is a growth rate\n\nThis equation yields a simple result:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL0 <- 13\nLmax <- 120\nr <- .3\ncurve(L0 * exp(-r*x) + Lmax*(1 - exp(-r * x)), xlim = c(0, 20))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\nThis is the equation in continuous time\n\nHowever we often measure animals at discreet moments in time, having as a reference their last measurement. We can use a discrete version of this equation in these cases:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvb_disc <- function(L_tm1, r, time, Lmax) {\n  L_tm1 * exp(-r*time) + Lmax*(1 - exp(-r * time))\n}\n\ntimevec <- rep(1, times = 13)\nsize <- numeric(length(timevec)+1)\nsize[1] <- 13\n\nfor (t in 1:length(timevec)){\n  size[t+1] = vb_disc(size[t],\n                      r = r,\n                      time = timevec[t],\n                      Lmax = Lmax)\n}\n\ncurve(L0 * exp(-r*x) + Lmax*(1 - exp(-r * x)),\n      xlim = c(0, 20))\npoints(cumsum(c(0,timevec)), size)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nThis works even if the points we measure at are not regular:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntimevec <- runif(n = 13, min = .7, max = 3)\nsize <- numeric(length(timevec)+1)\nsize[1] <- 13\n\nfor (t in 1:length(timevec)){\n  size[t+1] = vb_disc(size[t],\n                      r = r,\n                      time = timevec[t],\n                      Lmax = Lmax)\n}\n\ncurve(L0 * exp(-r*x) + Lmax*(1 - exp(-r * x)),\n      xlim = c(0, 20))\npoints(cumsum(c(0,timevec)), size)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nSo we can see that this is the same equation. Let's simulate observations of a growing animal with measurement error\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL0 <- 13\nLmax <- 120\nr <- .3\nsigma = 2\n\ngrow_data <- tibble(time = seq(from = .5, to = 21, length.out = 40),\n       size = L0 * exp(-r* time) + Lmax*(1 - exp(-r * time)),\n       size_obs = rnorm(n = length(size), mean = size, sd = sigma))\n\ngrow_data |> \n  ggplot(aes(x = time, y = size_obs)) + geom_point()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n## Translating the model to Stan\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvb_discrete <- cmdstan_model(\n  here::here(\n    \"posts/2023-10-23-discrete-vb-brms-stan/vb_discrete_meas.stan\"),\n  pedantic = TRUE)\n\nvb_discrete \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.stan}\ndata {\n  int<lower=0> n;\n  real age_first_meas;\n  vector[n-1] time_diff;\n  vector[n] obs_size;\n  int<lower=0> n_pred;\n  vector[n_pred-1] diff_pred;\n}\nparameters {\n  real<lower=0> Lstart;\n  real<lower=0> Lmax;\n  real<lower=0> r;\n  real<lower=0> sigma;\n}\nmodel {\n  Lstart ~ normal(10, 2);\n  Lmax ~ normal(120, 10);\n  r ~ exponential(1);\n  sigma ~ exponential(1);\n\n  // could add measurment error to age\n  obs_size[1] ~ normal(Lstart * exp(-r*age_first_meas) + Lmax*(1 - exp(-r * age_first_meas)), sigma);\n  obs_size[2:n] ~ normal(obs_size[1:(n-1)] .* exp(-r*time_diff) + Lmax*(1 - exp(-r*time_diff)), sigma);\n}\ngenerated quantities {\n  vector[n_pred] mu;\n  vector[n_pred] obs;\n  mu[1] = Lstart;\n\n  for (i in 2:n_pred){\n    mu[i] = mu[i-1] .* exp(-r*diff_pred[i-1]) + Lmax*(1 - exp(-r*diff_pred[i-1]));\n  }\n\n  for( j in 1:n_pred){\n    obs[j] = normal_rng(mu[j], sigma);\n  }\n\n}\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsome_obs <- grow_data |> \n  mutate(sampled = sample(sample(0:1, length(time), replace = TRUE, prob = c(.4, .6)))) |> \n  filter(sampled > 0) |> \n  # lagged time\n  mutate(time_diff = time - lag(time))\n\nfirst <- some_obs |> head(1)\nrest <- some_obs |> slice(-1)\n\ndiff_pred <- c(rep(2, times = 5), rep(5, 3))\n\nvb_discrete_post <- vb_discrete$sample(\n  data = list(\n    n = nrow(some_obs),\n    time_diff = rest$time_diff,\n    age_first_meas = first$time,\n    obs_size = some_obs$size_obs,\n    n_pred = length(diff_pred) + 1,\n    diff_pred = diff_pred\n  ),\n  refresh = 0\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRunning MCMC with 4 sequential chains...\n\nChain 1 finished in 0.1 seconds.\nChain 2 finished in 0.1 seconds.\nChain 3 finished in 0.1 seconds.\nChain 4 finished in 0.2 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.1 seconds.\nTotal execution time: 1.0 seconds.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvb_discrete_post$draws() |> \n  gather_rvars(mu[i]) |> \n  mutate(time = cumsum(c(0, diff_pred))) |> \n  ggplot(aes(x = time, dist = .value)) + \n  stat_lineribbon() + \n  scale_fill_brewer(palette = \"Greens\") +\n  geom_point(aes(x = time, y = size_obs), \n             inherit.aes = FALSE, data = grow_data)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Using the `size` aesthetic with geom_ribbon was deprecated in ggplot2 3.4.0.\nℹ Please use the `linewidth` aesthetic instead.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Unknown or uninitialised column: `linewidth`.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Using the `size` aesthetic with geom_line was deprecated in ggplot2 3.4.0.\nℹ Please use the `linewidth` aesthetic instead.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Unknown or uninitialised column: `linewidth`.\nUnknown or uninitialised column: `linewidth`.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvb_discrete_post$summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 23 × 10\n   variable    mean  median     sd    mad      q5     q95  rhat ess_bulk\n   <chr>      <num>   <num>  <num>  <num>   <num>   <num> <num>    <num>\n 1 lp__     -29.7   -29.3   1.56   1.31   -32.7   -27.9    1.00    1768.\n 2 Lstart    11.4    11.4   1.70   1.68     8.62   14.2    1.00    2837.\n 3 Lmax     120.    120.    2.70   2.63   116.    125.     1.00    2483.\n 4 r          0.297   0.296 0.0275 0.0264   0.253   0.343  1.00    2583.\n 5 sigma      2.50    2.46  0.383  0.362    1.96    3.20   1.00    3581.\n 6 mu[1]     11.4    11.4   1.70   1.68     8.62   14.2    1.00    2837.\n 7 mu[2]     60.0    60.0   2.64   2.47    55.6    64.3    1.00    3587.\n 8 mu[3]     86.8    86.9   2.79   2.66    82.0    91.2    1.00    3857.\n 9 mu[4]    102.    102.    2.34   2.23    97.7   105.     1.00    4545.\n10 mu[5]    110.    110.    2.01   1.91   107.    113.     1.00    4846.\n# ℹ 13 more rows\n# ℹ 1 more variable: ess_tail <num>\n```\n\n\n:::\n:::\n\n\n## can it be written in BRMS?\n\nI want to ask, what happens if we fit a similar model in brms? I'm using a lagged column of size.\n\nThis feels like a different model, but at least in this simple example, the posterior is close to the real value. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n## add a lagged growth measurement\nlagged_obs <- some_obs |> \n  mutate(sizelast = lag(size_obs)) |> \n  # drop first row\n  slice(-1)\n\nvb_formula <- bf(size_obs ~ sizelast * exp(- exp(logR) * time_diff) + \n                   sizeMax * (1 - exp(-exp(logR) * time_diff)),\n                 logR ~ 1,\n                 sizeMax ~ 1, nl = TRUE)\n\n\nget_prior(vb_formula, data = lagged_obs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                prior class      coef group resp dpar   nlpar lb ub\n student_t(3, 0, 4.8) sigma                                    0   \n               (flat)     b                              logR      \n               (flat)     b Intercept                    logR      \n               (flat)     b                           sizeMax      \n               (flat)     b Intercept                 sizeMax      \n       source\n      default\n      default\n (vectorized)\n      default\n (vectorized)\n```\n\n\n:::\n\n```{.r .cell-code}\nvb_prior <- c(\n  prior(normal(120, 10), nlpar = \"sizeMax\", class = \"b\"),\n  prior(normal(0, 1), nlpar = \"logR\", class = \"b\"),\n  prior(exponential(1), class = \"sigma\")\n)\n\n\nvb_post <- brm(vb_formula, \n               data = lagged_obs,\n               prior = vb_prior,\n               file = here::here(\"posts/2023-10-23-discrete-vb-brms-stan/vb_brms.rds\"), refresh = 0)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(vb_post)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Family: gaussian \n  Links: mu = identity; sigma = identity \nFormula: size_obs ~ sizelast * exp(-exp(logR) * time_diff) + sizeMax * (1 - exp(-exp(logR) * time_diff)) \n         logR ~ 1\n         sizeMax ~ 1\n   Data: lagged_obs (Number of observations: 28) \n  Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 4000\n\nPopulation-Level Effects: \n                  Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nlogR_Intercept       -1.12      0.13    -1.41    -0.87 1.00     2561     2247\nsizeMax_Intercept   119.29      3.19   113.38   126.18 1.00     2492     1794\n\nFamily Specific Parameters: \n      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma     3.05      0.40     2.40     3.94 1.00     2809     2233\n\nDraws were sampled using sampling(NUTS). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n\n\n:::\n\n```{.r .cell-code}\nrv <- c(\"b_logR_Intercept\" = \"r\", \n        \"b_sizeMax_Intercept\" = \"sizeMax\")\n\n\nvb_post |> \n  gather_rvars(b_logR_Intercept, b_sizeMax_Intercept) |> \n  mutate(.value = if_else(.variable == \"b_logR_Intercept\", exp(.value), .value),\n         parname = rv[.variable]) |> \n  ggplot(aes(x = parname, dist = .value)) + stat_pointinterval() + \n  facet_wrap(~parname, scales = \"free\") + \n  geom_point(aes(x = parname, y = value), \n             inherit.aes = FALSE,\n             data = tribble(\n               ~parname, ~value,\n               \"r\"      , r,\n               \"sizeMax\", Lmax\n             ), col = \"red\", size = 4)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Using the `size` aesthetic with geom_segment was deprecated in ggplot2 3.4.0.\nℹ Please use the `linewidth` aesthetic instead.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nHm! interestingly, it seems to work just fine.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}