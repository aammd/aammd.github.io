{
  "hash": "b6f2622f054a262d00c0e4c13ba1d088",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Modelling discrete growth\"\nauthor: \"Andrew MacDonald, Kelly Forester\"\ndescription: |\n  How to model the growth of things in a sensible fashion\ndate: 7 Nov 2023\neditor: source\ncategories: [UdeS, stan]\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(targets)\nlibrary(ggplot2)\nlibrary(tidyverse)\nlibrary(tidybayes)\n```\n:::\n\n\n##  growing things get bigger\n\nAnimals get bigger over time, and young change in size faster than more mature individuals. \nThe classic Von Bertanaffy growth equation has animals growing from a starting size to a final asymptotic size:\n\n$$\nL_t = L_0e^{-rt} + L_{max}(1 - e^{-rt})\n$$\n\n* $L_0$ is the starting size\n* $L_{max}$ is the final size\n* $r$ is a growth rate\n\nThis equation yields a simple result:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL0 <- 13\nLmax <- 120\nr <- .3\ncurve(L0 * exp(-r*x) + Lmax*(1 - exp(-r * x)), xlim = c(0, 20))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\nThis is the equation in continuous time\n\nHowever we often measure animals at discreet moments in time, having as a reference their last measurement. We can use a discrete version of this equation in these cases:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvb_disc <- function(L_tm1, r, time, Lmax) {\n  L_tm1 * exp(-r*time) + Lmax*(1 - exp(-r * time))\n}\n\ntimevec <- rep(1, times = 13)\nsize <- numeric(length(timevec)+1)\nsize[1] <- 13\n\nfor (t in 1:length(timevec)){\n  size[t+1] = vb_disc(size[t],\n                      r = r,\n                      time = timevec[t],\n                      Lmax = Lmax)\n}\n\ncurve(L0 * exp(-r*x) + Lmax*(1 - exp(-r * x)),\n      xlim = c(0, 20))\npoints(cumsum(c(0,timevec)), size)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nThis works even if the points we measure at are not regular:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntimevec <- runif(n = 13, min = .7, max = 3)\nsize <- numeric(length(timevec)+1)\nsize[1] <- 13\n\nfor (t in 1:length(timevec)){\n  size[t+1] = vb_disc(size[t],\n                      r = r,\n                      time = timevec[t],\n                      Lmax = Lmax)\n}\n\ncurve(L0 * exp(-r*x) + Lmax*(1 - exp(-r * x)),\n      xlim = c(0, 20))\npoints(cumsum(c(0,timevec)), size)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nSo we can see that this is the same equation. Let's simulate observations of a growing animal with measurement error\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL0 <- 13\nLmax <- 120\nr <- .3\nsigma = 2\n\ngrow_data <- tibble(time = seq(from = .5, to = 21, length.out = 40),\n       size = L0 * exp(-r* time) + Lmax*(1 - exp(-r * time)),\n       size_obs = rnorm(n = length(size), mean = size, sd = sigma))\n\ngrow_data |> \n  ggplot(aes(x = time, y = size_obs)) + geom_point()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n## Translating the model to Stan\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(cmdstanr)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThis is cmdstanr version 0.5.3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n- CmdStanR documentation and vignettes: mc-stan.org/cmdstanr\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n- CmdStan path: /Users/amacdonald/.cmdstan/cmdstan-2.31.0\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n- CmdStan version: 2.31.0\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nA newer version of CmdStan is available. See ?install_cmdstan() to install it.\nTo disable this check set option or environment variable CMDSTANR_NO_VER_CHECK=TRUE.\n```\n\n\n:::\n\n```{.r .cell-code}\nvb_discrete <- cmdstan_model(\n  here::here(\n    \"posts/2023-10-23-discrete-vb-brms-stan/vb_discrete_meas.stan\"),\n  pedantic = TRUE)\n\nvb_discrete \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.stan}\ndata {\n  int<lower=0> n;\n  real age_first_meas;\n  vector[n-1] time_diff;\n  vector[n] obs_size;\n  int<lower=0> n_pred;\n  vector[n_pred-1] diff_pred;\n}\nparameters {\n  real<lower=0> Lstart;\n  real<lower=0> Lmax;\n  real<lower=0> r;\n  real<lower=0> sigma;\n}\nmodel {\n  Lstart ~ normal(10, 2);\n  Lmax ~ normal(120, 10);\n  r ~ exponential(1);\n  sigma ~ exponential(1);\n\n  // could add measurment error to age\n  obs_size[1] ~ normal(Lstart * exp(-r*age_first_meas) + Lmax*(1 - exp(-r * age_first_meas)), sigma);\n  obs_size[2:n] ~ normal(obs_size[1:(n-1)] .* exp(-r*time_diff) + Lmax*(1 - exp(-r*time_diff)), sigma);\n}\ngenerated quantities {\n  vector[n_pred] mu;\n  vector[n_pred] obs;\n  mu[1] = Lstart;\n\n  for (i in 2:n_pred){\n    mu[i] = mu[i-1] .* exp(-r*diff_pred[i-1]) + Lmax*(1 - exp(-r*diff_pred[i-1]));\n  }\n\n  for( j in 1:n_pred){\n    obs[j] = normal_rng(mu[j], sigma);\n  }\n\n}\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsome_obs <- grow_data |> \n  mutate(sampled = sample(sample(0:1, length(time), replace = TRUE, prob = c(.4, .6)))) |> \n  filter(sampled > 0) |> \n  # lagged time\n  mutate(time_diff = time - lag(time))\n\nfirst <- some_obs |> head(1)\nrest <- some_obs |> slice(-1)\n\ndiff_pred <- c(rep(2, times = 5), rep(5, 3))\n\nvb_discrete_post <- vb_discrete$sample(\n  data = list(\n    n = nrow(some_obs),\n    time_diff = rest$time_diff,\n    age_first_meas = first$time,\n    obs_size = some_obs$size_obs,\n    n_pred = length(diff_pred) + 1,\n    diff_pred = diff_pred\n  ),\n  refresh = 0\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRunning MCMC with 4 sequential chains...\n\nChain 1 finished in 0.1 seconds.\nChain 2 finished in 0.1 seconds.\nChain 3 finished in 0.1 seconds.\nChain 4 finished in 0.1 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.1 seconds.\nTotal execution time: 1.1 seconds.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvb_discrete_post$draws() |> \n  gather_rvars(mu[i]) |> \n  mutate(time = cumsum(c(0, diff_pred))) |> \n  ggplot(aes(x = time, dist = .value)) + \n  stat_lineribbon() + \n  scale_fill_brewer(palette = \"Greens\") +\n  geom_point(aes(x = time, y = size_obs), \n             inherit.aes = FALSE, data = grow_data)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Using the `size` aesthetic with geom_ribbon was deprecated in ggplot2 3.4.0.\nℹ Please use the `linewidth` aesthetic instead.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Unknown or uninitialised column: `linewidth`.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Using the `size` aesthetic with geom_line was deprecated in ggplot2 3.4.0.\nℹ Please use the `linewidth` aesthetic instead.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Unknown or uninitialised column: `linewidth`.\nUnknown or uninitialised column: `linewidth`.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvb_discrete_post$summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 23 × 10\n   variable    mean  median     sd    mad      q5     q95  rhat ess_bulk\n   <chr>      <num>   <num>  <num>  <num>   <num>   <num> <num>    <num>\n 1 lp__     -14.7   -14.3   1.60   1.33   -17.6   -12.9    1.00    1521.\n 2 Lstart    11.3    11.3   1.80   1.71     8.26   14.2    1.00    2593.\n 3 Lmax     118.    118.    1.33   1.24   116.    120.     1.00    2828.\n 4 r          0.330   0.330 0.0205 0.0203   0.297   0.364  1.00    2405.\n 5 sigma      1.61    1.58  0.288  0.259    1.22    2.14   1.00    2826.\n 6 mu[1]     11.3    11.3   1.80   1.71     8.26   14.2    1.00    2593.\n 7 mu[2]     62.7    62.7   1.71   1.61    59.9    65.5    1.00    3658.\n 8 mu[3]     89.2    89.3   1.84   1.78    86.1    92.2    1.00    3422.\n 9 mu[4]    103.    103.    1.51   1.47   100.    105.     1.00    3820.\n10 mu[5]    110.    110.    1.23   1.18   108.    112.     1.00    4318.\n# ℹ 13 more rows\n# ℹ 1 more variable: ess_tail <num>\n```\n\n\n:::\n:::\n\n\n## can it be written in BRMS?\n\nI want to ask, what happens if we fit a similar model in brms? I'm using a lagged column of size.\n\nThis feels like a different model, but at least in this simple example, the posterior is close to the real value. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n## add a lagged growth measurement\nlagged_obs <- some_obs |> \n  mutate(sizelast = lag(size_obs)) |> \n  # drop first row\n  slice(-1)\n\nlibrary(brms)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: Rcpp\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading 'brms' package (version 2.19.0). Useful instructions\ncan be found by typing help('brms'). A more detailed introduction\nto the package is available through vignette('brms_overview').\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'brms'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:tidybayes':\n\n    dstudent_t, pstudent_t, qstudent_t, rstudent_t\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:stats':\n\n    ar\n```\n\n\n:::\n\n```{.r .cell-code}\nvb_formula <- bf(size_obs ~ sizelast * exp(- exp(logR) * time_diff) + \n                   sizeMax * (1 - exp(-exp(logR) * time_diff)),\n                 logR ~ 1,\n                 sizeMax ~ 1, nl = TRUE)\n\n\nget_prior(vb_formula, data = lagged_obs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                prior class      coef group resp dpar   nlpar lb ub\n student_t(3, 0, 4.9) sigma                                    0   \n               (flat)     b                              logR      \n               (flat)     b Intercept                    logR      \n               (flat)     b                           sizeMax      \n               (flat)     b Intercept                 sizeMax      \n       source\n      default\n      default\n (vectorized)\n      default\n (vectorized)\n```\n\n\n:::\n\n```{.r .cell-code}\nvb_prior <- c(\n  prior(normal(120, 10), nlpar = \"sizeMax\", class = \"b\"),\n  prior(normal(0, 1), nlpar = \"logR\", class = \"b\"),\n  prior(exponential(1), class = \"sigma\")\n)\n\n\nvb_post <- brm(vb_formula, \n               data = lagged_obs,\n               prior = vb_prior,\n               file = here::here(\"posts/2023-10-23-discrete-vb-brms-stan/vb_brms.rds\"), refresh = 0)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(vb_post)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Family: gaussian \n  Links: mu = identity; sigma = identity \nFormula: size_obs ~ sizelast * exp(-exp(logR) * time_diff) + sizeMax * (1 - exp(-exp(logR) * time_diff)) \n         logR ~ 1\n         sizeMax ~ 1\n   Data: lagged_obs (Number of observations: 28) \n  Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 4000\n\nPopulation-Level Effects: \n                  Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nlogR_Intercept       -1.12      0.13    -1.41    -0.87 1.00     2561     2247\nsizeMax_Intercept   119.29      3.19   113.38   126.18 1.00     2492     1794\n\nFamily Specific Parameters: \n      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma     3.05      0.40     2.40     3.94 1.00     2809     2233\n\nDraws were sampled using sampling(NUTS). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n\n\n:::\n\n```{.r .cell-code}\nrv <- c(\"b_logR_Intercept\" = \"r\", \n        \"b_sizeMax_Intercept\" = \"sizeMax\")\n\n\nvb_post |> \n  gather_rvars(b_logR_Intercept, b_sizeMax_Intercept) |> \n  mutate(.value = if_else(.variable == \"b_logR_Intercept\", exp(.value), .value),\n         parname = rv[.variable]) |> \n  ggplot(aes(x = parname, dist = .value)) + stat_pointinterval() + \n  facet_wrap(~parname, scales = \"free\") + \n  geom_point(aes(x = parname, y = value), \n             inherit.aes = FALSE,\n             data = tribble(\n               ~parname, ~value,\n               \"r\"      , r,\n               \"sizeMax\", Lmax\n             ), col = \"red\", size = 4)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Using the `size` aesthetic with geom_segment was deprecated in ggplot2 3.4.0.\nℹ Please use the `linewidth` aesthetic instead.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nHm! interestingly, it seems to work just fine.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}