{
  "hash": "c5a17d9d82eb15b50b8b334201cbbacd",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Useful Zeros: poisson mixtures and custom families\"\nauthor: \"Andrew MacDonald\"\ndescription: \"Making something out of the right kind of nothing.\"\ndate: 24 April 2025\neditor: source\ncategories: [UdeS, stan]\ndraft: false\neditor_options: \n  chunk_output_type: console\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(targets)\nlibrary(ggplot2)\nlibrary(tidyverse)\nlibrary(tidybayes)\nsuppressPackageStartupMessages(library(brms))\n```\n:::\n\n\n\n\n## The question\n\nWhen placed on a host place in a nice environment with no enemies, aphids produce new aphids exponentially.[to me they seem to be bacteria with legs]{/aside}\nBut host plants are not all good food, and on some aphids grow poorly -- but on others they grow well. \n\nWhat is the growth rate of these aphids on different host plants? What proportion of total variance can be assigned to genotype? \n\n## The design\n\nA large number of genotypes are chosen, three replicates per genotype. \nEach plant grown alone and is \"inoculated\" with two aphid nymphs. \nAt the end of **2 weeks** we count all the aphids, and model growth rate by the classic exponential \n\n$$\ny \\sim \\text{Poisson}(2e^{rt})\n$$\nand using 2 for the time parameter to get the weekly population growth rate. \n\n:::{.callout-note}\n### Poisson or?\nI feel like there are probably multiple ways to model the observation error of population growth, and Poisson is only one. EC Pielou gives another in her book, deriving a distribution for the population size of a growing population that is based on the Binomial distribution. Here I'm going with Poisson, but another post could explore another technique! \n:::\n\n## The problem\n\nAt the end of the experiment, we see that there are a suprisingly large number of zeros -- some plants have no aphids on them! \nAnd there's another surprising detail: when we calculate the mean and variance of aphid population size for each genotype, we find they have a _negative_ relationship. This is surprising because normally when the average of a count is high, the variance is higher too! \n\nWhat's going on?\n\n## The probability of death-by-experimenter ( $m$ )\n\nMaybe the aphids don't survive transfer to the host plant at the start. After all, in order to maximize the impact of the host plant on the female, the experimenters started them at as early an age as possible. \nI'll say that the probability of being killed in transfer is $m$. That means that by the time the aphids start reproducing, the plants can be put in three categories in three proportions:\n\n* $m^2$ plants have no aphids (both died)\n* $2m(1-m)$ plants have ONE aphid\n* $(1-m)^2$ plants have both aphids \n\nRight away, that suggests a sort of artisanal mixture model for the aphid population sizes:\n\n$$\n\\begin{align}\n\\text{Pr}(Y=0|m,r) &\\sim m^2 + 2m(1-m)\\times\\text{Poisson}(0|e^{rt}) + (1-m)^2\\times\\text{Poisson}(0|2e^{rt}) \\\\\n\\text{Pr}(Y=y|m,r) &\\sim 2m(1-m)\\times\\text{Poisson}(y|e^{rt}) + (1-m)^2\\times\\text{Poisson}(y|2e^{rt}) \\\\\nm &\\sim \\text{Beta}(2,5) \\\\\nr &\\sim \\text{Normal}(1.5, 2) \\\\\n\\end{align}\n$$\nI guess you could call this a \"zero-inflated mixture of Poissons\".\nBut the name doesn't matter as much, what is interesting it that it follows logically from the experimental situation described. \n\n:::{.callout-note}\n## some observations about this model \n\n* I feel like this notation (and the model code) would be \"tighter\" if you replace $Pois(0|e^{rt})$ with the probability of zero in a poisson distribution: $e^{-\\lambda}$ which in this case would be $e^{-e^{rt}}. But I also think that would make the model less readable, which is a BAD thing!\n* We decided to use a Normal prior for r since it is possible to be both negative or positive. Most of the prior probability in _this_ model is positive, though, because these animals are supposed to do well on these plants!\n* I suppose you could give $m$ a logit link and model it as caused by different factors, such as the experimenter who transferred the immature insects at the start, or maybe even something about the host plants. However, here we're treating it as a constant!\n:::\n\n## Simulation study: identical hosts\n\nThe goal is the same as always: simulate the data-generating process and see if models can fit it! I try lots of things here, and eventually build up to fitting and testing the model i just described in a Stan program, and then in a brms workflow.\n\n### Exponential growth, no mortality: simplest model\n\nHere is a simple model of exponential population growth with poisson variation, just to confirm it works as I thought it would\n\n$$\n\\begin{align}\n\\text{abd} &\\sim \\text{Poisson}(N_0e^{rt}) \\\\\nr &\\sim \\text{Normal}(1.5,.2)  \\\\\n\\end{align}\n$$\n\nIn all the stan code that follows, you'll see that I've written this on the log scale. I have a few reasons for doing this.\nOne is that population growth rates are usually modelled as a log ratio, so this keeps the code looking more like the R scripts used for this kind of problem. \nAnother is that this is a [parameterization of the Poisson available in Stan](https://mc-stan.org/docs/functions-reference/unbounded_discrete_distributions.html#poisson-distribution-log-parameterization), which is a bit more efficient \n\n$$\n\\begin{align}\n\\text{abd} &\\sim \\text{PoissonLog}(\\ln{N_0} + rt) \\\\\nr &\\sim \\text{Normal}(1.5,.2)  \\\\\n\\end{align}\n$$\nHere is a simulated dataset for plenty of replicate clones: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrep <- 300\n\nr <- log(6)\n\naphid_data <- expand_grid(rep_id = 1:nrep, first_aphid = 1:2) |>\n  # expected aphids per aphid (No = 1)\n mutate(expect_aphids = 1*exp(r*2),\n        obs_aphids = rpois(n = length(expect_aphids), lambda = expect_aphids))\n\n# combine the two aphids per plant\naphid_data_sum <- aphid_data |> \n  group_by(rep_id) |> \n  summarize(obs_aphids = sum(obs_aphids))\n\nggplot(aphid_data_sum, aes(x = obs_aphids)) +\n  geom_histogram()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![Simulated population sizes after two weeks.](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n\nHere's the same model, written as a Stan program\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimple_growth <- cmdstanr::cmdstan_model(here::here(\n  \"posts/2025-03-12-useful-zeros/simple_growth.stan\"))\n\nsimple_growth \n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` stan\ndata{\n  int n;\n  real time;\n  real N0;\n  array[n] int abd;\n}\nparameters {\n  real r;\n}\nmodel {\n  r ~ normal(1.5, 2);\n  abd ~ poisson_log(log(N0) + r*time);\n\n}\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsimple_growth_post <- simple_growth$sample(\n  data = list(n = nrow(aphid_data_sum), \n              N0 = 2,\n              time = 2,\n              abd = aphid_data_sum$obs_aphids),\n  refresh = 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRunning MCMC with 4 sequential chains...\n\nChain 1 finished in 0.0 seconds.\nChain 2 finished in 0.0 seconds.\nChain 3 finished in 0.0 seconds.\nChain 4 finished in 0.0 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.0 seconds.\nTotal execution time: 0.6 seconds.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbayesplot::mcmc_areas(x = simple_growth_post$draws(), pars = \"r\") + \n  geom_vline(xintercept = r, col = \"red\", size = 1) + \n  # coord_cartesian(xlim = c(r*.99, r*1.01)) +\n  NULL\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nâ„¹ Please use `linewidth` instead.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![The posterior distribution covers the true value pretty well.](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n\n\n### Exponential growth, but with transfer mortality \n\nAs described above, we don't live in an easy world. We live in a world where aphids die sometimes as you transfer them. What does the data look like in that case?\nLet's say that you kill about 20% (a .8 chance of surviving).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naphid_data_surv <- aphid_data |> \n  mutate(surv = rbinom(n = length(first_aphid), size = 1, prob = .8),\n         obs_aphids = obs_aphids*surv) |> \n  # filter(surv == 1) |> \n  group_by(rep_id) |> \n  summarize(obs_aphids = sum(obs_aphids),\n            n=n(),\n            No = sum(surv))\n  \naphid_data_surv |> \n  ggplot(aes(x = obs_aphids)) + \n  geom_histogram() + \n  labs(x = \"Observed aphids\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![A histogram of aphid population sizes, if some aphids die when they are transferred at the experiment's start.](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\n#### Alternative models\n\nI have already described the mixture model above, but I want to compare this model with a few other possibilities:\n\n1. Ignore the problem and fit a model with $N_0 = 2$\n2. Drop all 0 abundances, and fit the $N_0 = 2$ model to the non-zero numbers\n4. *though experiment* imagine we know the starting sizes for all the populations (perhaps thanks to observations made a few days after the start of the experiment).\n3. add an observation-level random effect (on the log scale) to compensate for the variance introduced by the unpredictable starting densities.\n\nRather than write all these out in math, I'm just going to show the code for each! \n\nFor the first two listed above, we can reuse the original model and just change the data that goes in. The model is L\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimple_growth\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` stan\ndata{\n  int n;\n  real time;\n  real N0;\n  array[n] int abd;\n}\nparameters {\n  real r;\n}\nmodel {\n  r ~ normal(1.5, 2);\n  abd ~ poisson_log(log(N0) + r*time);\n\n}\n```\n\n\n:::\n:::\n\n\n\nAnother possibility is that we _know_ the starting population size. \nThis of course means modifying the model to let the starting population size be data instead:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimple_growth_knownN0 <- cmdstanr::cmdstan_model(\n  here::here(\"posts/2025-03-12-useful-zeros/simple_growth_knownN0.stan\"))\n\nsimple_growth_knownN0 \n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` stan\ndata{\n  int n;\n  real time;\n  vector[n] N0;\n  array[n] int abd;\n}\nparameters {\n  real<lower=0> r;\n}\nmodel {\n  abd ~ poisson_log(log(N0) + r*time);\n}\n```\n\n\n:::\n:::\n\n\n\nFinally we have an observation level random effect (OLRE) which is often used to model an overdispersed poisson. \nOn the log scale, the starting population size becomes the intercept of the linear model. \nThe random effect for each row might help represent the extra variation caused by the intercept having unpredictably values (that is, 2, 1, or 0):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimple_growth_olre <- cmdstanr::cmdstan_model(here::here(\n  \"posts/2025-03-12-useful-zeros/simple_growth_olre.stan\"))\n\nsimple_growth_olre \n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` stan\ndata{\n  int n;\n  real time;\n  real N0;\n  array[n] int abd;\n}\nparameters {\n  real r;\n  real<lower=0> sigma;\n  vector[n] obs_z;\n}\ntransformed parameters {\n  vector[n] obs_i = obs_z*sigma;\n}\nmodel {\n  obs_z ~ std_normal();\n  sigma ~ exponential(3);\n  r ~ normal(1.7, .2);\n  abd ~ poisson_log(log(N0) + r*time + obs_i);\n}\n```\n\n\n:::\n:::\n\n\n\nFitting and comparing each model\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimple_growth_mortality_post <- simple_growth$sample(\n  data = list(n = nrow(aphid_data_surv), \n              N0 = 2,\n              time = 2,\n              abd = aphid_data_surv$obs_aphids),\n  refresh = 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRunning MCMC with 4 sequential chains...\n\nChain 1 finished in 0.0 seconds.\nChain 2 finished in 0.0 seconds.\nChain 3 finished in 0.0 seconds.\nChain 4 finished in 0.0 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.0 seconds.\nTotal execution time: 0.5 seconds.\n```\n\n\n:::\n\n```{.r .cell-code}\nno_mort_r <- simple_growth_post |> \n  tidybayes::spread_rvars(r) |> \n  mutate(m = \"no mortality\")\n\nN02_0s_r <- simple_growth_mortality_post |> \n  tidybayes::spread_rvars(r) |> \n  mutate(m = \"N0=2, with 0s\") \n\nbind_rows(no_mort_r, N02_0s_r)|> \n  ggplot(aes(y = m, dist = r)) + \n  stat_halfeye() + \n  geom_vline(xintercept = r)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\naphid_no0 <- aphid_data_surv |> \n  filter(No >0)\n\nsimple_growth_dropzero_post <- simple_growth$sample(\n  data = list(n = nrow(aphid_no0), \n              N0 = 2,\n              time = 2,\n              abd = aphid_no0$obs_aphids),\n  refresh = 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRunning MCMC with 4 sequential chains...\n\nChain 1 finished in 0.0 seconds.\nChain 2 finished in 0.0 seconds.\nChain 3 finished in 0.0 seconds.\nChain 4 finished in 0.0 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.0 seconds.\nTotal execution time: 0.5 seconds.\n```\n\n\n:::\n\n```{.r .cell-code}\nno_mort_r <- simple_growth_post |> \n  tidybayes::spread_rvars(r) |> \n  mutate(m = \"no mortality\")\n\nN02_0s_r <- simple_growth_mortality_post |> \n  tidybayes::spread_rvars(r) |> \n  mutate(m = \"N0=2, with 0s\") \n\nN02_drop0_r <- simple_growth_dropzero_post |> \n  tidybayes::spread_rvars(r) |> \n  mutate(m = \"N0=2, drop 0s\") \n\n## known N0\nsimple_known_N0_post <- simple_growth_knownN0$sample(\n  data = list(n = nrow(aphid_no0), \n              N0 = aphid_no0$No,\n              time = 2,\n              abd = aphid_no0$obs_aphids),\n  refresh = 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRunning MCMC with 4 sequential chains...\n\nChain 1 finished in 0.0 seconds.\nChain 2 finished in 0.0 seconds.\nChain 3 finished in 0.0 seconds.\nChain 4 finished in 0.0 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.0 seconds.\nTotal execution time: 0.5 seconds.\n```\n\n\n:::\n\n```{.r .cell-code}\nknown_N0_r <- simple_known_N0_post |> \n  tidybayes::spread_rvars(r) |> \n  mutate(m = \"N0 known, with 0s\") \n\n## Observation level random effect\nsimple_growth_olre_post <- simple_growth_olre$sample(\n  data = list(n = nrow(aphid_data_surv), \n              N0 = 2,\n              time = 2,\n              abd = aphid_data_surv$obs_aphids),\n  refresh = 0, parallel_chains = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRunning MCMC with 4 parallel chains...\n\nChain 4 finished in 1.0 seconds.\nChain 1 finished in 1.1 seconds.\nChain 2 finished in 1.1 seconds.\nChain 3 finished in 1.1 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 1.1 seconds.\nTotal execution time: 1.2 seconds.\n```\n\n\n:::\n\n```{.r .cell-code}\nolre_r <- simple_growth_olre_post |> \n  tidybayes::spread_rvars(r) |> \n  mutate(m = \"OLRE, with 0s\") \n  \n\nbind_rows(no_mort_r, \n          N02_0s_r, \n          N02_drop0_r,\n          known_N0_r,\n          olre_r)|> \n  ggplot(aes(y = m, dist = r)) + \n  stat_halfeye() + \n  geom_vline(xintercept = r)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\nNone of these work particularly well, though I'm truly surprised that the observation level random effect created such a biased estimate! \nIs there anything short of knowing the true value a the start of the experiment that could help us? \n\n\n### Estimating mortality and mixtures\n\nHere is the mixture model from earlier, expressed in Stan\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmixture_growth <- cmdstanr::cmdstan_model(\n  here::here(\"posts/2025-03-12-useful-zeros/mixture_growth.stan\"))\n\nmixture_growth \n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` stan\ndata{\n  int n;\n  real time;\n  // real N0;\n  array[n] int abd;\n}\nparameters {\n  real r;\n  real<lower=0,upper=1> m;\n}\nmodel {\n  m ~ beta(3,3);\n  r ~ normal(1.8, .2);\n\n  for (i in 1:n) {\n    if (abd[i] == 0) {\n      target += log_sum_exp(\n        [\n          2*log(m),\n          log(2)+log(m)+log1m(m)\n          + poisson_log_lpmf(abd[i] | r*time),\n          2*log1m(m)\n          + poisson_log_lpmf(abd[i] | log(2) + r*time)\n        ]\n        );\n    } else {\n      target += log_sum_exp(\n        log(2)+log(m)+log1m(m)\n        + poisson_log_lpmf(abd[i] | r*time),\n        2*log1m(m)\n        + poisson_log_lpmf(abd[i] | log(2) + r*time)\n        );\n    }\n  }\n}\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmixture_growth_post <- mixture_growth$sample(\n  data = list(n = nrow(aphid_data_surv), \n              time = 2,\n              abd = aphid_data_surv$obs_aphids),\n  refresh = 0, parallel_chains = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRunning MCMC with 4 parallel chains...\n\nChain 1 finished in 0.5 seconds.\nChain 2 finished in 0.5 seconds.\nChain 3 finished in 0.5 seconds.\nChain 4 finished in 0.6 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.5 seconds.\nTotal execution time: 0.7 seconds.\n```\n\n\n:::\n\n```{.r .cell-code}\nmixture_r <- mixture_growth_post |> \n  tidybayes::spread_rvars(r) |> \n  mutate(m = \"mixture\") \n  \n\nbind_rows(no_mort_r, \n          N02_0s_r, \n          N02_drop0_r,\n          known_N0_r,\n          olre_r,\n          mixture_r)|> \n  ggplot(aes(y = m, dist = r)) + \n  stat_halfeye() + \n  geom_vline(xintercept = r)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n\n\n## Simulate the experimental design \n\n## multiple clones\n\nIn the actual experiment there will be a large number of clones, with 3 replicates in each. \n(The actual experiment also includes a block ID that is crossed with genotype, but I'm leaving that out of this simulation because here I'm just focused on correctly estimating the average growth rate. In a later post I might try to extend this model to include that detail also!)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nngenotypes <- 300\n\nrep_per_geno <- 3\n\nr_bar <- 1.3\n\nr_sd <- .5\n\nr_geno <- rnorm(n = ngenotypes, mean = r_bar, sd = r_sd)\n\ncurve(1*exp(r_bar*x), xlim = c(0,2.5), lwd = 2)\nwalk(r_geno, ~curve(exp(.*x), add = TRUE, lwd = .5))\n```\n\n::: {.cell-output-display}\n![Variation in growth rates among plant genotypes. These curves are drawn with the base r function `curve`, to illustrate how variation among genotypes creates differences in exponential growth.](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\nNow its time to simulate the design:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## project the growth of each original female\naphid_clone_data <- expand_grid(\n  rep_id = 1:rep_per_geno,\n  clone_id = 1:ngenotypes,\n  first_aphid = 1:2,\n  ) |>\n mutate(\n   clone_r = r_geno[clone_id],\n   expect_aphids = 1*exp(clone_r*2),\n   obs_aphids = rpois(n = length(expect_aphids), lambda = expect_aphids)\n   )\n\n## sum the offspring of each initial female into a total!\naphid_clone_total <- aphid_clone_data |> \n  group_by(rep_id, clone_id) |> \n  summarize(clone_r = unique(clone_r),\n            expect_aphids_tot = sum(expect_aphids),\n            obs_aphids_tot = sum(obs_aphids)) |> \n  ungroup()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'rep_id'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n```{.r .cell-code}\nknitr::kable(head(aphid_clone_total))\n```\n\n::: {.cell-output-display}\n\n\n| rep_id| clone_id|   clone_r| expect_aphids_tot| obs_aphids_tot|\n|------:|--------:|---------:|-----------------:|--------------:|\n|      1|        1| 0.8592557|          11.15244|             11|\n|      1|        2| 1.4512208|          36.43715|             33|\n|      1|        3| 2.4531072|         270.25379|            282|\n|      1|        4| 1.0450358|          16.17099|             14|\n|      1|        5| 1.4717657|          37.96553|             37|\n|      1|        6| 1.1723096|          20.85860|             24|\n\n\n:::\n:::\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\naphid_clone_total |> \n  # filter(obs_aphids_tot>0) |> \n  mutate(clone_id = forcats::fct_reorder(\n    as.character(clone_id), obs_aphids_tot),\n    rgr = log(obs_aphids_tot/2)/2) |> \n  ggplot(aes(x = clone_id, y = rgr)) + \n  geom_point()  + \n  labs(y = \"Relative growth rate\")\n\naphid_clone_total |> \n  ggplot(aes(x = obs_aphids_tot)) + \n  geom_histogram()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![Relative growth rates as measured for each clone](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![Histogram of population sizes](index_files/figure-html/unnamed-chunk-15-2.png){width=672}\n:::\n\nResults of a model *without* mortality: Relative growth rates of aphids at the end of the experiment, where genotypes are different in their growth rates.\n:::\n\n\n\n\n:::{.callout-warning}\n### Maybe not a Poisson after all\n\nThe figure above reveals a subtle problem with this Poisson model of population growth: it generates impossible predictions for population sizes. Specifically, its possible to draw a 0 or 1 by random chance from a Poisson distribution with a low mean. But we might want to consider that these aphid populations never actually decrease, for example because even the first-born aphids survive to the end of the experiment (which is only 2 weeks, in a controlled environment with no enemies and lots of resources). There are other ways of working with this, but the full exploration will have to be a different post! \n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naphid_clone_total |> \n  group_by(clone_id) |>\n  summarize(mean_abd = mean(obs_aphids_tot),\n            var_abd = var(obs_aphids_tot)) |> \n  ggplot(aes(x = mean_abd, y = var_abd)) + geom_point()+ \n  geom_abline(slope = 1, intercept = 0) + \n  stat_smooth(method = \"lm\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![the mean and variance are kind of correlated, because these are observations drawn from a poisson distribution. Compare the figure below, which shows that small sample bias can make the trend look rather far from 1:1.](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\n### Model fitting to recover parameters -- no mortality\n\nThis calls for a model of growth that is hierarchical, so that individual host genotypes have thier own average growth rate:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimple_growth_hier <- cmdstanr::cmdstan_model(\n  here::here(\"posts/2025-03-12-useful-zeros/simple_growth_hier.stan\"))\n\nsimple_growth_hier\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` stan\ndata{\n  int n;\n  int nclone;\n  real time;\n  // real N0;\n  array[n] int abd;\n  array[n] int clone_id;\n}\nparameters {\n  real r_bar;\n  real<lower=0,upper=1> m;\n  real<lower=0> r_sd;\n  vector[nclone] r_z;\n}\ntransformed parameters {\n  vector[nclone] r_i = r_bar + r_z*r_sd;\n}\nmodel {\n  // priors\n  m ~ beta(4,4);\n  r_bar ~ normal(1.8, .2);\n  r_sd ~ exponential(3);\n  r_z ~ std_normal();\n\n  for (i in 1:n) {\n      target +=  poisson_log_lpmf(abd[i] | log(2) + r_i[clone_id[i]]*time);\n    }\n}\n```\n\n\n:::\n:::\n\n\n\n\nThen we run the sampler on the data from the simulation. \nRemember that the true values for the parameters are \n\n* `r_bar`: 1.3\n* `r_sd`: 0.5\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimple_growth_hier_post <- simple_growth_hier$sample(\n  data = list(n = nrow(aphid_clone_total), \n              time = 2,\n              abd = aphid_clone_total$obs_aphids_tot,\n              nclone = max(aphid_clone_total$clone_id),\n              clone_id = aphid_clone_total$clone_id),\n  refresh = 0, parallel_chains = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRunning MCMC with 4 parallel chains...\n\nChain 2 finished in 4.5 seconds.\nChain 3 finished in 5.7 seconds.\nChain 1 finished in 5.8 seconds.\nChain 4 finished in 5.8 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 5.4 seconds.\nTotal execution time: 5.9 seconds.\n```\n\n\n:::\n\n```{.r .cell-code}\nsimple_growth_hier_post$summary(variables = c(\"r_bar\", \"m\", \"r_sd\")) |> \n  knitr::kable()\n```\n\n::: {.cell-output-display}\n\n\n|variable |      mean|   median|        sd|       mad|        q5|       q95|     rhat|   ess_bulk|  ess_tail|\n|:--------|---------:|--------:|---------:|---------:|---------:|---------:|--------:|----------:|---------:|\n|r_bar    | 1.2937220| 1.294205| 0.0314846| 0.0339071| 1.2404100| 1.3444215| 1.048016|   60.30351|  126.6434|\n|m        | 0.4961621| 0.494539| 0.1653054| 0.1791322| 0.2279260| 0.7654714| 0.999813| 6127.19256| 3414.3892|\n|r_sd     | 0.5051465| 0.504177| 0.0216511| 0.0206089| 0.4716005| 0.5433092| 1.053516|  149.79032|  249.8677|\n\n\n:::\n:::\n\n\n\nLooks like we're getting pretty close!\n\n:::{.callout-note}\n### Mean-variance relationships in the Poisson distribution\n\nWe often say things like \"the mean and the variace of a Poisson are both equal to the parameter $\\lambda$, AKA the rate parameter\". But what does this really look like in a sample? Here is a little bit of `purrr` code that demonstrates what this looks like:\n\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nplot_poisson_meanvar <- function(n){\n  1:35 |> \n    rep(each = 4) |> \n    map(~rpois(n=n, .x ))|> \n    map_df(~tibble(mean = mean(.x),\n                   var = var(.x))) |> \n    ggplot(aes(x = mean, y = var)) + \n    geom_point() + \n    geom_abline(intercept = 0, slope = 1) + \n    coord_fixed() + \n    # stat_smooth(method = \"lm\") + \n    NULL\n}\n\nplot_poisson_meanvar(n = 500)\nplot_poisson_meanvar(n = 3)\n```\n\n::: {.cell-output-display}\n![500 samples in each Poisson](index_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![3 samples in each Poisson](index_files/figure-html/unnamed-chunk-19-2.png){width=672}\n:::\n\nSamples from the Poisson distribution, as $\\lambda$ increases. Sample size makes a big difference in what the mean-variance relationship looks like, and how clear it is. In these simulations I change the $\\lambda$ parameter from 1 to 35 in increments of 1, and repeat the sampling 4 times for each value of $\\lambda$. The only thing that is different is the sample size of each sample: either 500 samples (left) or only 3 (right). \n:::\n\n\n\nIt seems it can be pretty hard to establish a clear \"expected\" mean-variance relationship in a Poisson!\nThat makes sense to me, since a variance is pretty hard to measure accurately.\n\n:::\n\n## Adding mortality\n\nThis section uses the same simulation from above but adds in the mortality during the transfer process, with a 20% chance of killing the aphid.\n\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nsurv_prob <- .8\n\n# go back to original and remove some aphids before summing\n\naphid_clone_mort_dat <- aphid_clone_data |> \n  mutate(surv = rbinom(length(obs_aphids), size = 1, prob = surv_prob),\n         obs_aphids_alive = obs_aphids * surv)\n\naphid_clone_mort_sum <- aphid_clone_mort_dat |>\n  group_by(clone_id, rep_id) |>\n  summarize(tot_aphids = sum(obs_aphids_alive))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'clone_id'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n```{.r .cell-code}\naphid_clone_mort_sum |> \n  summarize(mean_abd = mean(tot_aphids),\n            var_abd = var(tot_aphids)) |> \n  ungroup() |> \n  ggplot(aes(x = mean_abd, y =var_abd)) + geom_point() + \n  geom_abline(slope = 1, intercept = 0) + \n  stat_smooth(method = \"lm\") + \n  # coord_cartesian(xlim = c(0, 150), ylim = c(-20,400))\n  NULL\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![Some initial mortality in aphids being transferred to plants means that the variance gets bigger faster than the average.](index_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n\n```{.r .cell-code}\naphid_clone_mort_sum |> \n  ungroup() |> \n  mutate(clone_id = forcats::fct_reorder(\n    as.character(clone_id), tot_aphids)) |> \n  ggplot(aes(x = clone_id, y = log(tot_aphids))) + geom_point()\n```\n\n::: {.cell-output-display}\n![Some initial mortality in aphids being transferred to plants means that the variance gets bigger faster than the average.](index_files/figure-html/unnamed-chunk-20-2.png){width=672}\n:::\n:::\n\n\n\nThe mixture model from above only needs one extension to work for these data: add a random effect on the `r` parameter:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmixture_growth_hier <- cmdstanr::cmdstan_model(\n  here::here(\"posts/2025-03-12-useful-zeros/mixture_growth_hier.stan\"))\n\nmixture_growth_hier\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` stan\ndata{\n  int n;\n  int nclone;\n  real time;\n  // real N0;\n  array[n] int abd;\n  array[n] int clone_id;\n}\nparameters {\n  real r_bar;\n  real<lower=0,upper=1> m;\n  real<lower=0> r_sd;\n  vector[nclone] r_z;\n}\ntransformed parameters {\n  vector[nclone] r_i = r_bar + r_z*r_sd;\n}\nmodel {\n  // priors\n  m ~ beta(4,4);\n  r_bar ~ normal(1.8, .2);\n  r_sd ~ exponential(3);\n  r_z ~ std_normal();\n\n  for (i in 1:n) {\n    if (abd[i] == 0) {\n      target += log_sum_exp(\n        [\n          2*log(m),\n          log(2)+log(m)+log1m(m)\n          + poisson_log_lpmf(abd[i] | r_i[clone_id[i]]*time),\n          2*log1m(m)\n          + poisson_log_lpmf(abd[i] | log(2) + r_i[clone_id[i]]*time)\n        ]\n        );\n    } else {\n      target += log_sum_exp(\n        log(2)+log(m)+log1m(m)\n        + poisson_log_lpmf(abd[i] | r_i[clone_id[i]]*time),\n        2*log1m(m)\n        + poisson_log_lpmf(abd[i] | log(2) + r_i[clone_id[i]]*time)\n        );\n    }\n  }\n}\n```\n\n\n:::\n:::\n\n\n\n\nAnd we feed it precisely the same data as in the heierarcical model that didn't know about transfer mortality:\n\n* `r_bar`: 1.3\n* `m`: 0.2\n* `r_sd`: 0.5\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmixture_growth_post <- mixture_growth_hier$sample(\n  data = list(n = nrow(aphid_clone_mort_sum), \n              time = 2,\n              abd = aphid_clone_mort_sum$tot_aphids,\n              nclone = max(aphid_clone_mort_sum$clone_id),\n              clone_id = aphid_clone_mort_sum$clone_id),\n  refresh = 0, parallel_chains = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRunning MCMC with 4 parallel chains...\n\nChain 3 finished in 21.3 seconds.\nChain 4 finished in 21.7 seconds.\nChain 1 finished in 21.9 seconds.\nChain 2 finished in 21.9 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 21.7 seconds.\nTotal execution time: 21.9 seconds.\n```\n\n\n:::\n\n```{.r .cell-code}\nmixture_growth_post$summary()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: The ESS has been capped to avoid unstable estimates.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 604 Ã— 10\n   variable      mean    median      sd     mad       q5      q95  rhat ess_bulk\n   <chr>        <dbl>     <dbl>   <dbl>   <dbl>    <dbl>    <dbl> <dbl>    <dbl>\n 1 lp__     -3254.    -3254.    20.2    20.2    -3.29e+3 -3.22e+3  1.09    45.7 \n 2 r_bar        1.30      1.30   0.0289  0.0284  1.26e+0  1.35e+0  1.03   196.  \n 3 m            0.203     0.203  0.0136  0.0135  1.81e-1  2.26e-1  1.05    55.6 \n 4 r_sd         0.509     0.508  0.0232  0.0229  4.72e-1  5.48e-1  1.01   270.  \n 5 r_z[1]      -1.31     -1.31   0.295   0.292  -1.79e+0 -8.35e-1  1.00  4352.  \n 6 r_z[2]       0.295     0.289  0.131   0.123   8.72e-2  5.15e-1  1.01   693.  \n 7 r_z[3]       2.40      2.32   0.240   0.181   2.10e+0  2.86e+0  1.53     7.50\n 8 r_z[4]      -0.663    -0.659  0.192   0.186  -9.83e-1 -3.54e-1  1.00  2770.  \n 9 r_z[5]       0.265     0.223  0.221   0.161  -7.14e-4  8.03e-1  1.01   656.  \n10 r_z[6]      -0.142    -0.147  0.187   0.162  -4.29e-1  1.46e-1  1.00  1957.  \n# â„¹ 594 more rows\n# â„¹ 1 more variable: ess_tail <dbl>\n```\n\n\n:::\n:::\n\n\n\n:::{.callout-note}\nI THOUGHT this model was working poorly but it turns out that it was just fine -- I was forgetting to sum the aphids before I ran the model. I only found my mistake because I spent a good amount of time digging back into my code to confirm.\n\nHere is one of the stripped-down models that I experimented with before finally realizing why it didn't work. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimple_growth_NOThier <- cmdstanr::cmdstan_model(\n  here::here(\"posts/2025-03-12-useful-zeros/simple_growth_NOThier.stan\"))\n\nsimple_growth_NOThier\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` stan\ndata{\n  int n;\n  int nclone;\n  real time;\n  // real N0;\n  array[n] int abd;\n  array[n] int clone_id;\n}\nparameters {\n  // real r_bar;\n  real<lower=0,upper=1> m;\n  // real<lower=0> r_sd;\n  vector[nclone] r_i;\n}\n// transformed parameters {\n//   vector[nclone] r_i = r_bar + r_z*r_sd;\n// }\nmodel {\n  // priors\n  // m ~ beta(4,4);\n  // r_bar ~ normal(1.8, .2);\n  // r_sd ~ exponential(3);\n  // r_z ~ std_normal();\n  r_i ~ normal(1.8, .3);\n\n  for (i in 1:n) {\n      target +=  poisson_log_lpmf(abd[i] | log(2) + r_i[clone_id[i]]*time);\n    }\n}\n```\n\n\n:::\n:::\n\n\n:::\n\n\n### Attempting a brms model (doesn't work)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# sum(aphid_clone_mort_sum$tot_aphids<1)\n# aphid_clone_mort_sum$tot_aphids |> length()\n# \n# wt_avg_bf <- brms::bf(\n#   tot_aphids ~ log(2*m*(1-m) + (1-m)^2) - log(1-m^2) + r*2,\n#   hu ~ m^2,\n#   nl = TRUE,\n#   r ~ 1 + (1|clone_id),\n#   m ~ 1,\n#   family = hurdle_poisson(link = \"log\", link_hu = \"identity\")\n#   )\n# \n# get_prior(wt_avg_bf, data = aphid_clone_mort_sum )\n# \n# wt_avg_priors <- c(\n#   prior(beta(.2*45, (1-.2)*45),\n#         nlpar = \"m\",class = \"b\", coef = \"Intercept\", lb = 0, ub=1),\n#   prior(normal(1.8, .3), nlpar = \"r\", class = \"b\", coef = \"Intercept\"),\n#   prior(exponential(3), nlpar = \"r\", class = \"sd\")\n# )\n# \n# wt_avg_post <- brm(wt_avg_bf, prior = wt_avg_priors, data = aphid_clone_mort_sum)\n```\n:::\n\n\n\n\nTurns out, it isn't really possible to use a \"nonlinear\" equation in both parts of the model -- that is, in the expression for the poisson and also for the number of 0s. \n\n### brms custom distribution\n\nThis is the first time I've ever tried to make a [custom family](https://cran.r-project.org/web/packages/brms/vignettes/brms_customfamilies.html) in brms. So I've broken the process down into steps. \n\n* make sure I have working Stan functions\n* run the brms code from the vignette with my new functions as a custom family\n* fit to simulated data.\n\n### Writing Stan program -- with functions\n\nLet's return to the simplest simulation I made: no variation among host plant clones, just replicates:\n\nOnce again, it was this model:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmixture_growth <- cmdstanr::cmdstan_model(\n  here::here(\"posts/2025-03-12-useful-zeros/mixture_growth.stan\"))\n\nmixture_growth \n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` stan\ndata{\n  int n;\n  real time;\n  // real N0;\n  array[n] int abd;\n}\nparameters {\n  real r;\n  real<lower=0,upper=1> m;\n}\nmodel {\n  m ~ beta(3,3);\n  r ~ normal(1.8, .2);\n\n  for (i in 1:n) {\n    if (abd[i] == 0) {\n      target += log_sum_exp(\n        [\n          2*log(m),\n          log(2)+log(m)+log1m(m)\n          + poisson_log_lpmf(abd[i] | r*time),\n          2*log1m(m)\n          + poisson_log_lpmf(abd[i] | log(2) + r*time)\n        ]\n        );\n    } else {\n      target += log_sum_exp(\n        log(2)+log(m)+log1m(m)\n        + poisson_log_lpmf(abd[i] | r*time),\n        2*log1m(m)\n        + poisson_log_lpmf(abd[i] | log(2) + r*time)\n        );\n    }\n  }\n}\n```\n\n\n:::\n:::\n\n\n\nand these data\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naphid_data_surv |> \n  ggplot(aes(x = obs_aphids)) + \n  geom_histogram()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n\nAnd the fit was excellent, recovering true parameters:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmixture_growth_post <- mixture_growth$sample(\n  data = list(n = nrow(aphid_data_surv), \n              time = 2,\n              abd = aphid_data_surv$obs_aphids),\n  refresh = 0, parallel_chains = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRunning MCMC with 4 parallel chains...\n\nChain 1 finished in 0.6 seconds.\nChain 2 finished in 0.5 seconds.\nChain 3 finished in 0.5 seconds.\nChain 4 finished in 0.5 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.5 seconds.\nTotal execution time: 0.7 seconds.\n```\n\n\n:::\n\n```{.r .cell-code}\nmixture_growth_post$summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 Ã— 10\n  variable      mean    median      sd     mad        q5      q95  rhat ess_bulk\n  <chr>        <dbl>     <dbl>   <dbl>   <dbl>     <dbl>    <dbl> <dbl>    <dbl>\n1 lp__     -1245.    -1244.    0.951   0.697   -1246.    -1.24e+3  1.00    2114.\n2 r            1.79      1.79  0.00407 0.00414     1.79   1.80e+0  1.00    4011.\n3 m            0.187     0.187 0.0157  0.0156      0.161  2.13e-1  1.00    1982.\n# â„¹ 1 more variable: ess_tail <dbl>\n```\n\n\n:::\n:::\n\n\n\ntrue $r$ was 1.7917595\n\n#### Rewriting it with a function\n\nMy plan is to rewrite the Stan program with a function in it\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmixture_growth_fn <- cmdstanr::cmdstan_model(\n  here::here(\"posts/2025-03-12-useful-zeros/mixture_growth_fn.stan\"))\n\nmixture_growth_fn \n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` stan\nfunctions {\n  real poisson_mix_mortality(int abd_i, real mu, real m) {\n    real ll;\n    if (abd_i == 0) {\n      ll = log_sum_exp(\n        [\n          2 * log(m),\n          log(2) + log(m) + log1m(m) + poisson_log_lpmf(abd_i | mu),\n          2 * log1m(m) + poisson_log_lpmf(abd_i | log(2) + mu)\n        ]\n      );\n    } else {\n      ll = log_sum_exp(\n        log(2) + log(m) + log1m(m) + poisson_log_lpmf(abd_i | mu),\n        2 * log1m(m) + poisson_log_lpmf(abd_i | log(2) + mu)\n      );\n    }\n    return ll;\n  }\n}\ndata{\n  int n;\n  real time;\n  // real N0;\n  array[n] int abd;\n}\nparameters {\n  real r;\n  real<lower=0,upper=1> m;\n}\nmodel {\n  real mu = r*time;\n  for (i in 1:n) {\n    target += poisson_mix_mortality(abd[i], mu, m);\n  }\n}\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmixture_growth_fn_post <- mixture_growth_fn$sample(\n  data = list(n = nrow(aphid_data_surv), \n              time = 2,\n              abd = aphid_data_surv$obs_aphids),\n  refresh = 0, parallel_chains = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRunning MCMC with 4 parallel chains...\n\nChain 1 finished in 0.5 seconds.\nChain 2 finished in 0.5 seconds.\nChain 3 finished in 0.5 seconds.\nChain 4 finished in 0.5 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.5 seconds.\nTotal execution time: 0.7 seconds.\n```\n\n\n:::\n\n```{.r .cell-code}\nmixture_growth_fn_post$summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 Ã— 10\n  variable      mean    median      sd     mad        q5      q95  rhat ess_bulk\n  <chr>        <dbl>     <dbl>   <dbl>   <dbl>     <dbl>    <dbl> <dbl>    <dbl>\n1 lp__     -1241.    -1241.    0.957   0.712   -1243.    -1.24e+3  1.00    1676.\n2 r            1.79      1.79  0.00411 0.00406     1.79   1.80e+0  1.00    4098.\n3 m            0.185     0.185 0.0156  0.0159      0.160  2.11e-1  1.00    2216.\n# â„¹ 1 more variable: ess_tail <dbl>\n```\n\n\n:::\n:::\n\n\n\nresults are the same! Now to inject it into brms\n\n### custom brms distribuion\n\nThis is the code taken straight from the brms vignette linked above, and adapted for our situation:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoisson_mix_mortality <- custom_family(\n  \"poisson_mix_mortality\",\n  dpars = c(\"mu\", \"m\"),\n  links = c(\"identity\", \"identity\"),\n  lb = c(NA, 0), ub = c(NA,1),\n  type = \"int\", \n  #vars = \"vint1[n]\"\n  loop = TRUE\n)\n```\n:::\n\n\n\nDefine Stan functions\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoisson_mix_mortality_fns <- \"\nreal poisson_mix_mortality_lpmf(int abd_i, real mu, real m) {\n    real ll;\n    if (abd_i == 0) {\n      ll = log_sum_exp(\n        [\n          2 * log(m),\n          log(2) + log(m) + log1m(m) + poisson_log_lpmf(abd_i | mu),\n          2 * log1m(m) + poisson_log_lpmf(abd_i | log(2) + mu)\n        ]\n      );\n    } else {\n      ll = log_sum_exp(\n        log(2) + log(m) + log1m(m) + poisson_log_lpmf(abd_i | mu),\n        2 * log1m(m) + poisson_log_lpmf(abd_i | log(2) + mu)\n      );\n    }\n    return ll;\n  }\nint poisson_mix_mortality_rng(real mu, real m) {\n real p1 = square(m);  // Pr[0] component: both die\n real p2 = 2 * m * (1 - m);  // One dies, one lives\n real p3 = square(1 - m);    // Both live\n\n    // Normalize to ensure valid probabilities\n real total = p1 + p2 + p3;\n p1 /= total;\n p2 /= total;\n p3 /= total;\n\n    // Sample which mortality path to take\n    real u = uniform_rng(0, 1);\n    int n;\n    if (u < p1) {\n      n = 0;  // both dead\n    } else if (u < p1 + p2) {\n      n = poisson_log_rng(mu);  // one survives\n    } else {\n      n = poisson_log_rng(log(2) + mu);  // both survive\n    }\n\n    return n;\n  }\n\"\n\nstanvars <- stanvar(scode = poisson_mix_mortality_fns,\n                    block = \"functions\")\n```\n:::\n\n\n\nWith this objects created, the next step is to assemble the brms model formula: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoisson_mix_bf <- bf(\n  tot_aphids ~ 0 + time + (0 + time | clone_id), \n  family = poisson_mix_mortality)\n\npoisson_mix_bf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntot_aphids ~ 0 + time + (0 + time | clone_id) \n```\n\n\n:::\n:::\n\n\n\nUsing brms in this way lets us define a prior over parameters that I came up with myself! \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_prior(poisson_mix_bf, data = aphid_clone_mort_sum |> \n    mutate(time = 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                 prior class coef    group resp dpar nlpar lb ub       source\n                (flat)     b                                          default\n                (flat)     b time                                (vectorized)\n                (flat)     m                                0  1      default\n student_t(3, 0, 20.8)    sd                                0         default\n student_t(3, 0, 20.8)    sd      clone_id                  0    (vectorized)\n student_t(3, 0, 20.8)    sd time clone_id                  0    (vectorized)\n```\n\n\n:::\n\n```{.r .cell-code}\npois_mix_prior <- c(\n  prior(normal(1.5, 2), class = \"b\", coef = \"time\"),\n  prior(beta(7*.3, 7*(1-.3)), class = \"m\", lb = 0, ub = 1),\n  prior(exponential(3), class=\"sd\", lb = 0)\n)\n\npois_mix_prior\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                        prior class coef group resp dpar nlpar   lb   ub source\n               normal(1.5, 2)     b time                       <NA> <NA>   user\n beta(7 * 0.3, 7 * (1 - 0.3))     m                               0    1   user\n               exponential(3)    sd                               0 <NA>   user\n```\n\n\n:::\n:::\n\n\n\nNow instead of a Stan-style list we can use the regular dataframe:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(aphid_clone_mort_sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 Ã— 3\n# Groups:   clone_id [2]\n  clone_id rep_id tot_aphids\n     <int>  <int>      <int>\n1        1      1          5\n2        1      2          3\n3        1      3          8\n4        2      1         33\n5        2      2         18\n6        2      3         41\n```\n\n\n:::\n:::\n\n\n\nWe just need to add a `time` column (which is all the same number) and put it in the regular model syntax:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhier_poisson_mix_brm <- brm(\n  tot_aphids ~ 0 + time + (0 + time | clone_id), \n  data = aphid_clone_mort_sum |> \n    mutate(time = 2),\n  family = poisson_mix_mortality,\n  stanvars = stanvars,\n  prior = pois_mix_prior,\n  chains = 2, cores = 2, refresh = 0\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCompiling Stan program...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nStart sampling\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: The largest R-hat is 1.84, indicating chains have not mixed.\nRunning the chains for more iterations may help. See\nhttps://mc-stan.org/misc/warnings.html#r-hat\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable.\nRunning the chains for more iterations may help. See\nhttps://mc-stan.org/misc/warnings.html#bulk-ess\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Tail Effective Samples Size (ESS) is too low, indicating posterior variances and tail quantiles may be unreliable.\nRunning the chains for more iterations may help. See\nhttps://mc-stan.org/misc/warnings.html#tail-ess\n```\n\n\n:::\n\n```{.r .cell-code}\nhier_poisson_mix_brm\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Parts of the model have not converged (some Rhats are > 1.05). Be\ncareful when analysing the results! We recommend running more iterations and/or\nsetting stronger priors.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Family: poisson_mix_mortality \n  Links: mu = identity; m = identity \nFormula: tot_aphids ~ 0 + time + (0 + time | clone_id) \n   Data: mutate(aphid_clone_mort_sum, time = 2) (Number of observations: 900) \n  Draws: 2 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 2000\n\nMultilevel Hyperparameters:\n~clone_id (Number of levels: 300) \n         Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsd(time)     0.51      0.02     0.47     0.56 1.00      183      418\n\nRegression Coefficients:\n     Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\ntime     1.30      0.03     1.24     1.36 1.03       98      244\n\nFurther Distributional Parameters:\n  Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nm     0.21      0.01     0.18     0.24 1.06       27      889\n\nDraws were sampled using sampling(NUTS). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n\n\n:::\n:::\n\n\n\n<!-- the real goal could be said to be measuring the growth rate of each species accurately. It would be interesting to, for each model, quantify the proportion of true genotype growth rates that are within the middle 95% of the distribution of predicted growth rates for that model. -->\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}