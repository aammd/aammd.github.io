{
  "hash": "d9328a55264d160b38ff655ca1fc1506",
  "result": {
    "markdown": "---\ntitle: \"Breakpoint regression in Stan\"\nauthor: \"Andrew MacDonald\"\ndescription: |\n  Two lines diverged at a particular point.\ndate: 05 Aug 2023\neditor: source\ncategories: [UdeS, stan, QCBS]\nimage: breakpoint-1.png\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(tidyverse)\nlibrary(tidybayes)\nlibrary(cmdstanr)\n```\n:::\n\n\n##  Two (or more) relationships\n\nIn breakpoint regression, we think that the relationship between two things can be described by two lines which alternate at a specific point. \n\nWhen might this happen? One case is when a rate is determined by the _minimum_ value of two functions^[see Leibig's Law of the Minimum, and also Dune]. For an example, consider cars driving down a series of roads. The roads vary in their speed limit, and each car is driven by very lawful drivers who always drive precisely the speed limit\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(x = 0:1, y = 0:1) |> \n  ggplot(aes(x = x, y = y)) + \n  geom_abline(slope = 1, intercept = 0) + \n  labs(x = \"speed limit\", y = \"Car speed\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\nHowever, some of these highways have VERY high speed limits. The cars, however, can't keep up: eventually they hit their max speed. When that happens, the lawful drivers hold steady at the fastest speed their car can maintain. Together, you get a kind of \"hockey stick\" shape:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntribble(~ limit, ~ max,\n        0, 0,\n        200, 200) |> \n  ggplot(aes(x = limit, y = max)) + \n  geom_point(col = \"white\") + \n  geom_abline(slope = 0, intercept = 100, lty = 2, lwd = 2, col = \"grey\") + \n  geom_label(aes(x = 10, y = 105, label = \"Max speed\")) + \n  geom_abline(slope = 1, intercept = 0, lty = 2, lwd = 2) + \n  theme_classic() + \n  labs(x = \"Speed limit\", y = \"Car speed\")\n```\n\n::: {.cell-output-display}\n![Car speed equals the speed limit, right up to the car's maximum velocity. Then, it doesn't matter how high the limit is, the car has to stay at maximum speed.](bk_intro-1.png){width=672}\n:::\n:::\n\n\n\n### Not so fast! \n\nNot every car is going to go at the exact manufacturers maximum speed! When (in my imaginary example) manufacturers release a new kind of car, they test a sample of cars to measure their maximum speed. Therefore we know the max speed (with some error) for that _brand_ of car. However, the realized max speed for any specific car in the wild will be **lower** than this value. This could be caused by a host of unmeasured factors, such as that particular car's defects, the kind of care it has received, etc\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntribble(~ limit, ~ max,\n        0, 0,\n        200, 200) |> \n  ggplot(aes(x = limit, y = max)) + \n  geom_point(col = \"white\") + \n  geom_abline(slope = 0, intercept = 100, lty = 2, lwd = 2, col = \"grey\") + \n  geom_label(aes(x = 25, y = 105, label = \"Factory Max speed\")) + \n  geom_abline(slope = 0, intercept = 80, lty = 2, lwd = 1, col = \"orange\") + \n  geom_label(aes(x = 25, y = 85, label = \"Actual max speed\")) + \n  geom_abline(slope = 1, intercept = 0, lty = 2, lwd = 2) + \n  theme_classic() + \n  labs(x = \"Speed limit\", y = \"Car speed\")\n```\n\n::: {.cell-output-display}\n![Car speed equals the speed limit, right up to the car's maximum velocity -- decreased a little bit by particularities of this specific car.](breakpoint-1.png){width=672}\n:::\n:::\n\n\n\n## Write that in mathematics\n\nfor one car, driving on different roads. \n\n* We label the different roads $i$\n* $\\tau$ is the maximum speed of this particular kind of car\n* $M$ is a bunch of measurements of the car's max speed (based on factory cars)\n* $p$ is the proportion of that maximum that our actual car has\n\n$$\n\\begin{align}\nY_i &\\sim \\text{Normal}(\\mu_i, \\sigma)\\\\\nM &\\sim \\text{Normal}(\\tau, \\sigma_m)\\\\\n\\mu_i & = \\begin{cases}\n    X_i & \\text{if } X_i \\leq p\\tau \\\\\n    p\\tau & \\text{if } X_i > p\\tau\n\\end{cases} \\\\\n\\text{logit}(p) &\\sim \\text{Normal}(2, .5) \\\\\n\\tau &\\sim \\text{Normal}(...) \\\\ \n\\sigma_m &\\sim \\text{Exponential}(...) \\\\ \n\\sigma &\\sim \\text{Exponential}(...)\n\\end{align}\n$$\n\n## Simple Stan code with prior predictions\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbreakpoint_B <- cmdstan_model(here::here(\"posts/2023-07-05-breakpoint/breakpoint_B.stan\"))\nbreakpoint_B\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\ndata {\n  int n;\n  vector[n] x;\n  real B;\n}\n// transformed data {\n//   real M = max(x);\n// }\nparameters {\n real b2;\n real<lower=0> sigma;\n}\nmodel {\n  b2 ~ normal(1, 1);\n  sigma ~ exponential(1);\n}\ngenerated quantities {\n  vector[n] y;\n  for( i in 1:n){\n    if (x[i] < B) {\n      y[i] = normal_rng(x[i]*b2, sigma);\n    } else {\n      y[i] = normal_rng(B*b2, sigma);\n    }\n  }\n}\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nxvar <- runif(42, min = 1, max=55)\n\nbreakpoint_B_prior <- breakpoint_B$sample(chains=1,\n                                      data = list(x = xvar,\n                                                  n = 42,\n                                                  B = 25))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 1 chain...\n\nChain 1 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 1 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 1 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 1 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 1 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 1 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 1 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 1 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 1 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 1 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 1 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 1 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 1 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 1 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 1 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 1 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 1 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 1 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 1 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 1 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 1 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 1 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 1 finished in 0.1 seconds.\n```\n:::\n\n```{.r .cell-code}\nbreakpoint_B_prior\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n variable  mean median    sd   mad     q5   q95 rhat ess_bulk ess_tail\n    lp__  -2.22  -1.84  1.17  0.85  -4.79 -1.07 1.00      343      477\n    b2     1.00   1.01  1.06  1.02  -0.72  2.78 1.00      504      446\n    sigma  1.04   0.71  1.09  0.80   0.04  3.15 1.00      464      350\n    y[1]  10.05  10.31 10.76 10.35  -7.35 27.93 1.00      515      483\n    y[2]  12.06  12.27 12.94 12.44  -9.36 33.46 1.00      500      510\n    y[3]  25.03  25.37 26.59 25.91 -17.43 69.54 1.00      505      447\n    y[4]  24.96  25.52 26.54 25.56 -18.15 69.41 1.00      505      444\n    y[5]  25.02  24.87 26.62 25.81 -18.28 69.16 1.00      506      456\n    y[6]  24.97  25.14 26.68 25.96 -18.58 69.22 1.00      501      455\n    y[7]  25.04  25.53 26.53 25.60 -18.65 68.77 1.00      506      444\n\n # showing 10 of 45 rows (change via 'max_rows' argument or 'cmdstanr_max_rows' option)\n```\n:::\n:::\n\n\nplot it\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprior_draws <- breakpoint_B_prior |> \n  tidybayes::gather_draws(y[i], ndraws = 12) |> \n  mutate(x = xvar[i])\n\nprior_draws |> \n  ggplot(aes(x = x, y = .value)) + geom_point() + \n  facet_wrap(~.draw)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n## extending it\n\nI want to play with reparameterizing the model using a proportion. \nThis represents the location of the breakpoint: somewhere between 0 and the maximum of the x axis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbreakpoint <- cmdstanr::cmdstan_model(\n  here::here(\"posts/2023-07-05-breakpoint/breakpoint.stan\"))\n\nset.seed(4812)\n\nxvar <- runif(42, min = 1, max=55)\n\nbreakpoint_prior <- breakpoint$sample(chains=1,\n                                      data = list(x = xvar,\n                                                  n = 42))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 1 chain...\n\nChain 1 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 1 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 1 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 1 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 1 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 1 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 1 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 1 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 1 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 1 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 1 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 1 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 1 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 1 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 1 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 1 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 1 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 1 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 1 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 1 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 1 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 1 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 1 finished in 0.1 seconds.\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprior_draws <- breakpoint_prior |> \n  tidybayes::gather_draws(y[i], ndraws = 12) |> \n  mutate(x = xvar[i])\n\nprior_draws |> \n  ggplot(aes(x = x, y = .value)) + geom_point() + \n  facet_wrap(~.draw)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\ngenerating quantities from a mixture:\n\nfirst use beta ccdf to decide if it is below or above the breakpoint using a random number\nthen pick from one or the other of the two normal distributions\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}