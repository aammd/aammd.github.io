{
  "hash": "6a3f66a16d65ac3c5ca1dae06896da8b",
  "result": {
    "markdown": "---\ntitle: \"Breakpoint regression in Stan\"\nauthor: \"Andrew MacDonald\"\ndescription: |\n  Two lines diverged at a particular point.\ndate: 05 Aug 2023\neditor: source\ncategories: [UdeS, stan, QCBS]\nimage: breakpoint-1.png\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(tidyverse)\nlibrary(tidybayes)\nlibrary(cmdstanr)\n```\n:::\n\n\n##  Two (or more) relationships\n\nIn breakpoint regression, we think that the relationship between two things can be described by two lines which alternate at a specific point. \n\nWhen might this happen? One case is when a rate is determined by the _minimum_ value of two functions^[see Leibig's Law of the Minimum, and also Dune]. For an example, consider cars driving down a series of roads. The roads vary in their speed limit, and each car is driven by very lawful drivers who always drive precisely the speed limit\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(x = 0:1, y = 0:1) |> \n  ggplot(aes(x = x, y = y)) + \n  geom_abline(slope = 1, intercept = 0) + \n  labs(x = \"speed limit\", y = \"Car speed\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/concept-1.png){width=672}\n:::\n:::\n\n\nHowever, some of these highways have VERY high speed limits. The cars, however, can't keep up: eventually they hit their max speed. When that happens, the lawful drivers hold steady at the fastest speed their car can maintain. Together, you get a kind of \"hockey stick\" shape:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntribble(~ limit, ~ max,\n        0, 0,\n        200, 200) |> \n  ggplot(aes(x = limit, y = max)) + \n  geom_point(col = \"white\") + \n  geom_abline(slope = 0, intercept = 100, lty = 2, lwd = 2, col = \"grey\") + \n  geom_label(aes(x = 10, y = 105, label = \"Max speed\")) + \n  geom_abline(slope = 1, intercept = 0, lty = 2, lwd = 2) + \n  theme_classic() + \n  labs(x = \"Speed limit\", y = \"Car speed\")\n```\n\n::: {.cell-output-display}\n![Car speed equals the speed limit, right up to the car's maximum velocity. Then, it doesn't matter how high the limit is, the car has to stay at maximum speed.](bk_intro-1.png){width=672}\n:::\n:::\n\n\n\n### Not so fast! \n\nNot every car is going to go at the exact manufacturers maximum speed! When (in my imaginary example) manufacturers release a new kind of car, they test a sample of cars to measure their maximum speed. Therefore we know the max speed (with some error) for that _brand_ of car. However, the realized max speed for any specific car in the wild will be **lower** than this value. This could be caused by a host of unmeasured factors, such as that particular car's defects, the kind of care it has received, etc\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntribble(~ limit, ~ max,\n        0, 0,\n        200, 200) |> \n  ggplot(aes(x = limit, y = max)) + \n  geom_point(col = \"white\") + \n  geom_abline(slope = 0, intercept = 100, lty = 2, lwd = 2, col = \"grey\") + \n  geom_label(aes(x = 25, y = 105, label = \"Factory Max speed\")) + \n  geom_abline(slope = 0, intercept = 80, lty = 2, lwd = 1, col = \"orange\") + \n  geom_label(aes(x = 25, y = 85, label = \"Actual max speed\")) + \n  geom_abline(slope = 1, intercept = 0, lty = 2, lwd = 2) + \n  theme_classic() + \n  labs(x = \"Speed limit\", y = \"Car speed\")\n```\n\n::: {.cell-output-display}\n![Car speed equals the speed limit, right up to the car's maximum velocity -- decreased a little bit by particularities of this specific car.](breakpoint-1.png){width=672}\n:::\n:::\n\n\n\n## Write that in mathematics\n\nfor one car, driving on different roads. \n\n* We label the different roads $i$\n* $\\tau$ is the maximum speed of this particular kind of car\n* $M$ is a bunch of measurements of the car's max speed (based on factory cars)\n* $p$ is the proportion of that maximum that our actual car has\n\n$$\n\\begin{align}\nY_i &\\sim \\text{Normal}(\\mu_i, \\sigma)\\\\\nM &\\sim \\text{Normal}(\\tau, \\sigma_m)\\\\\n\\mu_i & = \\begin{cases}\n    X_i & \\text{if } X_i \\leq p\\tau \\\\\n    p\\tau & \\text{if } X_i > p\\tau\n\\end{cases} \\\\\n\\text{logit}(p) &\\sim \\text{Normal}(2, .5) \\\\\n\\tau &\\sim \\text{Normal}(...) \\\\ \n\\sigma_m &\\sim \\text{Exponential}(...) \\\\ \n\\sigma &\\sim \\text{Exponential}(...)\n\\end{align}\n$$\n\n## Simple Stan code with prior predictions\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbreakpoint_B <- cmdstan_model(here::here(\"posts/2023-07-05-breakpoint/breakpoint_B.stan\"))\nbreakpoint_B\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\ndata {\n  int n;\n  vector[n] x;\n  real B;\n}\n// transformed data {\n//   real M = max(x);\n// }\nparameters {\n real b2;\n real<lower=0> sigma;\n}\nmodel {\n  b2 ~ normal(1, 1);\n  sigma ~ exponential(1);\n}\ngenerated quantities {\n  vector[n] y;\n  for( i in 1:n){\n    if (x[i] < B) {\n      y[i] = normal_rng(x[i]*b2, sigma);\n    } else {\n      y[i] = normal_rng(B*b2, sigma);\n    }\n  }\n}\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nxvar <- runif(42, min = 1, max=55)\n\nbreakpoint_B_prior <- breakpoint_B$sample(chains=1,\n                                      data = list(x = xvar,\n                                                  n = 42,\n                                                  B = 25))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 1 chain...\n\nChain 1 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 1 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 1 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 1 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 1 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 1 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 1 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 1 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 1 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 1 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 1 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 1 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 1 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 1 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 1 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 1 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 1 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 1 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 1 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 1 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 1 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 1 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 1 finished in 0.1 seconds.\n```\n:::\n\n```{.r .cell-code}\nbreakpoint_B_prior\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n variable  mean median    sd   mad     q5   q95 rhat ess_bulk ess_tail\n    lp__  -2.03  -1.74  1.02  0.75  -4.05 -1.05 1.00      369      698\n    b2     0.99   1.00  0.98  0.99  -0.60  2.56 1.00      903      756\n    sigma  0.98   0.68  0.99  0.68   0.05  2.91 1.00      474      472\n    y[1]  24.67  24.77 24.41 25.18 -15.78 63.32 1.00      905      756\n    y[2]  24.54  24.62 24.44 24.75 -15.88 63.44 1.00      910      756\n    y[3]  16.28  16.52 16.09 16.26 -10.15 41.77 1.00      900      755\n    y[4]  11.00  11.17 11.06 11.33  -7.27 28.69 1.00      924      781\n    y[5]  24.60  24.89 24.48 24.84 -15.86 63.72 1.00      906      780\n    y[6]  24.57  24.70 24.50 24.73 -16.28 63.97 1.00      908      781\n    y[7]  24.67  25.09 24.40 25.02 -14.97 64.21 1.00      909      738\n\n # showing 10 of 45 rows (change via 'max_rows' argument or 'cmdstanr_max_rows' option)\n```\n:::\n:::\n\n\nplot it\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprior_draws <- breakpoint_B_prior |> \n  tidybayes::gather_draws(y[i], ndraws = 12) |> \n  mutate(x = xvar[i])\n\nprior_draws |> \n  ggplot(aes(x = x, y = .value)) + geom_point() + \n  facet_wrap(~.draw)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n<!-- ## extending it -->\n\n<!-- I want to play with reparameterizing the model using a proportion.  -->\n<!-- This represents the location of the breakpoint: somewhere between 0 and the maximum of the x axis. -->\n\n<!-- ```{r} -->\n<!-- breakpoint <- cmdstanr::cmdstan_model( -->\n<!--   here::here(\"posts/2023-07-05-breakpoint/breakpoint.stan\")) -->\n\n<!-- set.seed(4812) -->\n\n<!-- xvar <- runif(42, min = 1, max=55) -->\n\n<!-- breakpoint_prior <- breakpoint$sample(chains=1, -->\n<!--                                       data = list(x = xvar, -->\n<!--                                                   n = 42)) -->\n\n<!-- ``` -->\n\n\n<!-- ```{r} -->\n<!-- prior_draws <- breakpoint_prior |>  -->\n<!--   tidybayes::gather_draws(y[i], ndraws = 12) |>  -->\n<!--   mutate(x = xvar[i]) -->\n\n<!-- prior_draws |>  -->\n<!--   ggplot(aes(x = x, y = .value)) + geom_point() +  -->\n<!--   facet_wrap(~.draw) -->\n<!-- ``` -->\n\n\n\n## Rewriting this with `step()`\n\nI learned from PhD student Dominique Caron that breakpoint regression can be written in brms using `step()`. \nThis is described in [this forum discussion](https://discourse.mc-stan.org/t/piecewise-linear-mixed-models-with-a-random-change-point/5306/4) and demonstrated in Stan code [here](https://gist.github.com/mbjoseph/25d649e46602a419f9765638d5a2bfbc).\nThe Stan manual [discusses step() among other logical functions](https://mc-stan.org/docs/functions-reference/logical-functions.html#logical-functions-1)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbreakpoint_step_prior <- cmdstanr::cmdstan_model(\n  here::here(\"posts/2023-07-05-breakpoint/breakpoint_step_prior.stan\"))\nbreakpoint_step_prior\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\ndata {\n  int n;\n  vector[n] x;\n  real B;\n}\nparameters {\n vector[n] y;\n real<lower=0> sigma;\n}\ntransformed parameters {\n  vector[n] x2;\n  for (i in 1:n){\n    x2[i] = step(B - x[i]);\n  }\n}\nmodel {\n  vector[n] mu;\n  mu = B + (x - B) .* x2;\n  y ~ normal(mu, sigma);\n  sigma ~ exponential(1);\n}\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(4812)\n\nxvar <- runif(42, min = 1, max=55)\n\nbreakpoint_step_prior_samples <- breakpoint_step_prior$sample(chains=1,\n                                      data = list(x = xvar,\n                                                  n = 42, B = 33), refresh = 0L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 1 chain...\n\nChain 1 finished in 0.7 seconds.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: 1 of 1 chains had an E-BFMI less than 0.2.\nSee https://mc-stan.org/misc/warnings for details.\n```\n:::\n\n```{.r .cell-code}\nprior_draws <- breakpoint_step_prior_samples |> \n  tidybayes::gather_draws(y[i], ndraws = 12) |> \n  mutate(x = xvar[i])\n\nprior_draws |> \n  ggplot(aes(x = x, y = .value)) + geom_point() + \n  facet_wrap(~.draw)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\nestimating breakpoints with some prior knowledge\n\nWe assume here that we have some unmeasured maximum. \nin my car example, the maximum speed of each kind of car is measured at the factory, by taking a random sample of cars and measuring their max speeds\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## take just one \none_dataset <- prior_draws |> \n  arrange(.draw) |> \n  head(42)\n\nbreakpoint_step_meas <- cmdstanr::cmdstan_model(\n  here::here(\"posts/2023-07-05-breakpoint/breakpoint_step_meas.stan\"))\n\nbreakpoint_step_meas\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\ndata {\n  int n;\n  vector[n] speed_limit;\n  vector[n] obs_speed;\n  real max_avg;\n  real max_sd;\n}\nparameters {\n  real max_speed;\n  real<lower=0> sigma;\n}\ntransformed parameters {\n  vector[n] V2;\n  for (i in 1:n){\n    V2[i] = step(max_speed - speed_limit[i]);\n  }\n}\nmodel {\n  vector[n] mu;\n  mu = max_speed + (speed_limit - max_speed) .* V2;\n  max_speed ~ normal(max_avg, max_sd);\n  obs_speed ~ normal(mu, sigma);\n  sigma ~ exponential(1);\n}\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbreakpoint_step_meas$sample(data = list(n  = 42, speed_limit = one_dataset$x, \n                                        obs_speed = one_dataset$.value,\n                                        max_avg = 30,\n                                        max_sd = 5), refresh = 0L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 4 sequential chains...\n\nChain 1 finished in 0.1 seconds.\nChain 2 finished in 0.1 seconds.\nChain 3 finished in 0.1 seconds.\nChain 4 finished in 0.1 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.1 seconds.\nTotal execution time: 0.8 seconds.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: NAs introduced by coercion\n\nWarning: NAs introduced by coercion\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n  variable   mean median   sd  mad     q5    q95 rhat ess_bulk ess_tail\n lp__      -18.53 -18.23 0.99 0.71 -20.57 -17.57 1.00     1745     1892\n max_speed  33.17  33.17 0.23 0.23  32.79  33.54 1.00     2427     2370\n sigma       0.93   0.91 0.11 0.10   0.77   1.11 1.00     3100     2272\n V2[1]       1.00   1.00 0.00 0.00   1.00   1.00   NA       NA       NA\n V2[2]       1.00   1.00 0.00 0.00   1.00   1.00   NA       NA       NA\n V2[3]       1.00   1.00 0.00 0.00   1.00   1.00   NA       NA       NA\n V2[4]       0.00   0.00 0.00 0.00   0.00   0.00   NA       NA       NA\n V2[5]       1.00   1.00 0.00 0.00   1.00   1.00   NA       NA       NA\n V2[6]       0.00   0.00 0.00 0.00   0.00   0.00   NA       NA       NA\n V2[7]       1.00   1.00 0.00 0.00   1.00   1.00   NA       NA       NA\n\n # showing 10 of 45 rows (change via 'max_rows' argument or 'cmdstanr_max_rows' option)\n```\n:::\n:::\n\n\n## Objects on the road are slower than they appear\n\nthe factory-measured speed is probably a lot higher than the top speed of the average car on the road. \nlots of factors intervene: the particular car's defects, its maitenance history, the fuel used, the driver's skill. \n\nAll of these factors will only DECREASE, and never increase, a car's speed relative to the maximum possible. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nbreakpoint_step_p <- cmdstanr::cmdstan_model(\n  here::here(\"posts/2023-07-05-breakpoint/breakpoint_step_p.stan\"))\nbreakpoint_step_p\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\ndata {\n  int n;\n  vector[n] speed_limit;\n  vector[n] obs_speed;\n  real max_avg;\n  real max_sd;\n}\nparameters {\n  real factory_speed;\n  real<lower=0> sigma;\n  real alpha;\n}\ntransformed parameters {\n  real max_speed;\n  max_speed = factory_speed * inv_logit(alpha);\n  vector[n] V2;\n  for (i in 1:n){\n    // step() is 0 if speed limit is over the maximum, 0 otherwise\n    // in other words, it gives the slope\n    V2[i] = step(max_speed - speed_limit[i]);\n  }\n}\nmodel {\n  vector[n] mu;\n  mu = max_speed + (speed_limit - max_speed) .* V2;\n  factory_speed ~ normal(max_avg, max_sd);\n  obs_speed ~ normal(mu, sigma);\n  alpha ~ normal(3, 2);\n  sigma ~ exponential(1);\n}\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbreakpoint_step_p$sample(data = list(n  = 42, \n                                     speed_limit = one_dataset$x, \n                                     obs_speed = one_dataset$.value,\n                                     max_avg = 30,\n                                     max_sd = 5), refresh = 0L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 4 sequential chains...\n\nChain 1 finished in 0.3 seconds.\nChain 2 finished in 0.3 seconds.\nChain 3 finished in 0.2 seconds.\nChain 4 finished in 0.2 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.3 seconds.\nTotal execution time: 1.5 seconds.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: 25 of 4000 (1.0%) transitions ended with a divergence.\nSee https://mc-stan.org/misc/warnings for details.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: NAs introduced by coercion\n\nWarning: NAs introduced by coercion\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n      variable   mean median   sd  mad     q5    q95 rhat ess_bulk ess_tail\n lp__          -19.12 -18.78 1.21 0.94 -21.36 -17.87 1.00     1012     1330\n factory_speed  34.06  33.75 0.98 0.71  33.02  36.11 1.02      374      315\n sigma           0.93   0.92 0.10 0.09   0.78   1.11 1.00     1210     1446\n alpha           4.30   4.12 1.38 1.39   2.41   6.87 1.01      361      358\n max_speed      33.15  33.16 0.23 0.23  32.76  33.54 1.00     3873     2936\n V2[1]           1.00   1.00 0.00 0.00   1.00   1.00   NA       NA       NA\n V2[2]           1.00   1.00 0.00 0.00   1.00   1.00   NA       NA       NA\n V2[3]           1.00   1.00 0.00 0.00   1.00   1.00   NA       NA       NA\n V2[4]           0.00   0.00 0.00 0.00   0.00   0.00   NA       NA       NA\n V2[5]           1.00   1.00 0.00 0.00   1.00   1.00   NA       NA       NA\n\n # showing 10 of 47 rows (change via 'max_rows' argument or 'cmdstanr_max_rows' option)\n```\n:::\n:::\n\n\nfirst thing that doesn't work well (admittedly, there is nothing in these simulated data to support this)\n\nsuggestion that the probability prior is very important\n\nperhaps if the same kind of car travelled on different highways in _several different countries_? in all countries the car would have the same theoretical maximum, but the difference in country-level factors mean that the proportion $p$ below that max, where the average car has its top speed, is going to vary.\n\nwhat other uncertainty is there to include? uncertainty in the speed limit perhaps? \n\nswitch for gamma errors\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}