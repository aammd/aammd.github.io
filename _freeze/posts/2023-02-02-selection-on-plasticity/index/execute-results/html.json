{
  "hash": "d435c1a5a17d76e932be3128ba0c9b09",
  "result": {
    "markdown": "---\ntitle: \"Validating a model of selection on plasticity\"\nauthor: \"Andrew MacDonald\"\ndescription: \"Plus Ã§a change, plus c'est la change qui change\"\ndate: 2023-02-02\ncategories: [UdeS, stan]\nexecute:\n  eval: false\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(cmdstanr)\nlibrary(tidyverse)\nlibrary(tidybayes)\n```\n:::\n\n\n\nLet's begin just with a simulation of three interrelated traits:\n\n* when a bird arrives, which determines\n* how many eggs they lay, out of which there is \n* some number of surviving offspring\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## how many birds\nnbirds <- 57\n# simulate arrival dates -- two weeks before and after whatever the average is\ndarrive <- runif(nbirds, min = -14, max = 14) |> round()\n\n## simulate clutch sizes -- decrease by 4% each day\navg_clutch <- 4.5\neffect_per_day <- .97\n\nclutch <- rpois(nbirds, exp(log(avg_clutch) + log(effect_per_day)*darrive))\n\nplot(darrive, clutch)\n```\n:::\n\n\nAs an aside, this would be 0-truncated, since birds who don't lay eggs don't get observed at all.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# simulate hatching success\nsuccess <- rbinom(nbirds, size = clutch, prob = .86)\n\nplot(darrive, success)\n```\n:::\n\n\nwhat's important to see here is that there is a negative correlation, even though the arrival date has no direct effect on the outcome\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(glm(success ~ darrive, family = \"poisson\"))\n```\n:::\n\n\n\nBut, if we use a binomial model that knows about the number of possible successful chicks, then we see what we expect: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nbin_mod <- (glm(cbind(success, clutch - success) ~ 1, family = binomial(link = \"logit\")))\n\nplogis(coef(bin_mod))\n```\n:::\n\n\nWhich matches the simulation above. \n\nif we put `darrive` in the model, the effect should be very close to 0 with overlap.\n\nIf we imagine that the laying date effects the survival p, then we should see an effect close to 0\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(glm(\n  cbind(success, clutch - success) ~ 1 + darrive,\n            family = binomial(link = \"logit\")))\n```\n:::\n\n\nOne Stan model can model all of these at the same time\n\n\n::: {.cell}\n\n```{.r .cell-code}\none_indiv <- cmdstanr::cmdstan_model(\n  here::here(\"posts/2023-02-02-selection-on-plasticity/one_indiv.stan\"))\n\none_indiv\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\none_indiv_post <- one_indiv$sample(\n  data = list(nbirds = nbirds,\n              clutch = clutch, \n              success = success, \n              darrive = darrive))\n\none_indiv_post\n```\n:::\n\n\nreasonably close to true values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplogis(1.44)\nlog(avg_clutch)\nlog(effect_per_day)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsimulate_some_birds <- function(nbirds = 57, \n         log_b_date = log(.97),\n         log_avgclutch = log(4.5),\n         logit_psuccess = qlogis(.84)){\n  \n  # simulate arrival dates -- two weeks before and after whatever the average is\n  darrive <- runif(nbirds, min = -14, max = 14) |> round()\n  \n  ## simulate clutch sizes -- decrease  each day\n  clutch <- rpois(nbirds, exp(log_avgclutch + log_b_date*darrive))\n  \n  ## simulate success\n  success <- rbinom(nbirds, size = clutch, prob = plogis(logit_psuccess))\n  \n  return(list(\n    data_list = list(\n      nbirds = nbirds,\n      darrive = darrive, \n      clutch = clutch, \n      success = success \n    ),\n    true_values = tribble(\n      ~variable, ~true_value,\n      \"log_b_date\", log_b_date,\n      \"log_avgclutch\", log_avgclutch,\n      \"logit_psuccess\", logit_psuccess\n    )\n  ))\n}\n\n\ndata_for_simulation <- simulate_some_birds()\n\none_indiv_post <- one_indiv$sample(data = data_for_simulation$data_list,\n                                   refresh = 0)\n\ncomparison <- one_indiv_post |> \n  # tidybayes::gather_rvars(logit_psuccess, log_avgclutch, log_b_date) |> \n  tidybayes::tidy_draws() |> tidybayes::gather_variables() |> \n  right_join(data_for_simulation$true_values, by = c(\".variable\" = \"variable\"))\n\n\ncomparison |> \n  ggplot(aes(y = .variable, x = .value)) + \n  stat_halfeye() + \n  geom_point(aes(y = variable, x = true_value),\n             col = \"orange\",\n             pch = \"|\",\n             size = 10, data = data_for_simulation$true_values)\n```\n:::\n\n\n## No 0 birds\n\nThis system is a little challenging, since we never observe 0 eggs per bird -- if a bird cannot lay eggs (e.g. it does not find a nest spot) then it goes uncounted\n\nTo simulate this, I'll drop the 0 clutches before doing the rest of the simulations. This means that sample size will be less than or equal to the \"nbirds\" argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimulate_some_birds_nonzero <- function(nbirds = 57, \n         log_b_date = log(.97),\n         log_avgclutch = log(4.5),\n         logit_psuccess = qlogis(.84)){\n  \n  # simulate arrival dates -- two weeks before and after whatever the average is\n  darrive <- runif(nbirds, min = -14, max = 14) |> round()\n  \n  ## simulate clutch sizes -- decrease  each day\n  clutch <- rpois(nbirds, exp(log_avgclutch + log_b_date*darrive))\n  # drop 0 nests\n  nonzero_clutch <- which(clutch > 0)\n  \n  ## simulate success\n  success <- rbinom(nbirds, size = clutch, prob = plogis(logit_psuccess))\n  \n  return(list(\n    data_list = list(\n      nbirds = length(nonzero_clutch),\n      darrive = darrive[nonzero_clutch], \n      clutch  =  clutch[nonzero_clutch], \n      success = success[nonzero_clutch] \n    ),\n    true_values = tribble(\n      ~variable, ~true_value,\n      \"log_b_date\", log_b_date,\n      \"log_avgclutch\", log_avgclutch,\n      \"logit_psuccess\", logit_psuccess\n    )\n  ))\n}\n\nset.seed(1234)\nsome_nonzeros <- simulate_some_birds_nonzero(nbirds = 200)\n```\n:::\n\n\na plot to confirm that it works:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsome_nonzeros$data_list |> \n  as.data.frame() |> \n  ggplot(aes(x = darrive, y = clutch)) + geom_point()\n```\n:::\n\n\nAnd fit the posterior\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_posterior_true <- function(simdata, stanmodel){\n  model_post <- stanmodel$sample(data = simdata$data_list,\n                                     refresh = 0, parallel_chains = 4)\n  \n  comparison <- model_post |> \n    tidybayes::tidy_draws() |> \n    tidybayes::gather_variables() |> \n    right_join(simdata$true_values, by = c(\".variable\" = \"variable\"))\n  \n  \n  comparison |> \n    ggplot(aes(y = .variable, x = .value)) + \n    stat_halfeye() + \n    geom_point(\n      aes(y = variable, x = true_value),\n      col = \"orange\",\n      pch = \"|\",\n      size = 10, data = simdata$true_values)\n}\n\n\nplot_posterior_true(some_nonzeros, one_indiv)\n```\n:::\n\n\nThere's already some bias happening! let's try what happens when the average is lower (and gives more 0s)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(420)\nsimulate_some_birds_nonzero(log_avgclutch = log(2.4),\n                            log_b_date = log(.7),\n                            nbirds = 300) |> \n  plot_posterior_true(one_indiv)\n```\n:::\n\n\nsome preliminary repetitions show that it usually misses either the average or the hatching success, frequently both. \n\n\n::: {.cell}\n\n```{.r .cell-code}\none_indiv_noZero <- cmdstanr::cmdstan_model(\n  here::here(\"posts/2023-02-02-selection-on-plasticity/one_indiv_noZero.stan\"))\n\none_indiv_noZero\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(420)\nsimulate_some_birds_nonzero(log_avgclutch = log(4.4),\n                            log_b_date = log(.9),\n                            nbirds = 300) |> \n  plot_posterior_true(one_indiv_noZero)\n```\n:::\n\n\n### Truncating using a different syntax\n\nThe manual [uses a different syntax](https://mc-stan.org/docs/stan-users-guide/truncated-data.html). \nTo write the equation above this way, I found I needed to make a few changes:\n\n* `poisson_log` has to be replaced with `poisson` and the `exp()` link function\n\n... that was actually the only change. \nIt runs at the same speed as the previous way of writing it, and gets the same answer:\n\n\n::: {.cell}\n\n```{.r .cell-code}\none_indiv_zerotrunc <- cmdstanr::cmdstan_model(\n  here::here(\"posts/2023-02-02-selection-on-plasticity/one_indiv_zerotrunc.stan\"))\n\none_indiv_zerotrunc\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(420)\nsimulate_some_birds_nonzero(log_avgclutch = log(4.4),\n                            log_b_date = log(.9),\n                            nbirds = 300) |> \n  plot_posterior_true(one_indiv_zerotrunc)\n```\n:::\n\n\n:::{.callout-note}\n# Two parameterizations diverged in a yellow wood\nThese two ways of writing the model both work. Which to choose? \nWell, I was pleased with myself for manually normalizing the Poisson likelihood in the first model. \nHowever the second is clearer to the reader. In the first, it takes two lines of code -- not even necessarily next to each other. In the second, the big `T` for *T*runcation indicates clearly what is going on. Code is communication; clarity wins.\n:::\n\n### Zero inflated binomial success\n\nOnce in a while, a nest will just be completely destroyed by, say, a predator. \nThis has nothing to do with anything, probably, and is just a catastrophic Act of Weasel. \nLet's imagine that some small proportion of the nests just die:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimulate_some_birds_nonzero_zeroinflated <- function(nbirds = 57, \n         log_b_date = log(.97),\n         log_avgclutch = log(4.5),\n         logit_psuccess = qlogis(.84),\n         logit_pfail = qlogis(.1)){\n  \n  # simulate arrival dates -- two weeks before and after whatever the average is\n  darrive <- runif(nbirds, min = -14, max = 14) |> round()\n  \n  ## simulate clutch sizes -- decrease  each day\n  clutch <- rpois(nbirds, exp(log_avgclutch + log_b_date*darrive))\n  # drop 0 nests\n  nonzero_clutch <- which(clutch > 0)\n  n_laid <- length(nonzero_clutch)\n  \n  # simulate success -- among birds which laid at least 1 egg, there is a chance of failing completely\n  success_among_nonzero <- rbinom(n_laid,\n                                  size = clutch[nonzero_clutch],\n                                  prob = plogis(logit_psuccess))\n  failed_nests <- rbinom(n_laid, size = 1, prob = plogis(logit_pfail))\n\n  success_zi <- success_among_nonzero * (1 - failed_nests)\n  \n  # success <- rbinom(nbirds, \n  #                   size = clutch,\n  #                   prob = plogis(logit_psuccess))\n  # failed_nests <- rbinom(nbirds, size = 1, prob = plogis(logit_pfail))\n  # \n  # success_zi <- success * (1 - failed_nests)\n  \n  return(list(\n    data_list = list(\n      nbirds = n_laid,\n      darrive = darrive[nonzero_clutch], \n      clutch  =  clutch[nonzero_clutch], \n      success = success_zi#[nonzero_clutch]\n    ),\n    true_values = tribble(\n      ~variable, ~true_value,\n      \"log_b_date\", log_b_date,\n      \"log_avgclutch\", log_avgclutch,\n      \"logit_psuccess\", logit_psuccess,\n      \"logit_pfail\", logit_pfail\n    )\n  ))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\none_indiv_ztrunc_zinf <- cmdstanr::cmdstan_model(\n  here::here(\"posts/2023-02-02-selection-on-plasticity/one_indiv_ztrunc_zinf.stan\"))\n\none_indiv_ztrunc_zinf\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(477)\nsome_zi_birds <- simulate_some_birds_nonzero_zeroinflated(log_avgclutch = log(4.4),\n                            log_b_date = log(.9),\n                            nbirds = 300) \n\nsome_zi_birds|> \n  plot_posterior_true(one_indiv_ztrunc_zinf)\n```\n:::\n\n\n\nI initially failed to recover the parameter for `logit_pfail`. Here I some things I learned: \n\n* Simulating zero-inflated numbers can be tricky! I flipped back and forth between simulating 0-inflation for all nests, and simulating for only those with at least 1 egg. In retrospect, it is clear that these are equivalent. There are two independent things here: the probability of a clutch having 0 eggs and the probability of a 0 coming from the zero-inflated binomial. \n* this zero-inflated model is quite _sensitive to the prior_. That's because there are not very many zeros being inflated: in my simulation at least, failed nests are rare and success is naturally low. it would be pretty important to decide in advance if sudden nest failure (e.g. by predation) is rare or common\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}