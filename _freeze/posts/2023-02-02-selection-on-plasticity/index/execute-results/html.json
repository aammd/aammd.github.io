{
  "hash": "00f8ba956f536b05fa2838090897898a",
  "result": {
    "markdown": "---\ntitle: \"Validating a model of selection on plasticity\"\nauthor: \"Andrew MacDonald\"\ndescription: \"Plus Ã§a change, plus c'est la change qui change\"\ndate: 2023-02-02\ncategories: [UdeS, stan]\ncode-block-bg: true\ncode-block-border-left: \"#31BAE9\"\nexecute:\n  eval: true\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(cmdstanr)\nlibrary(tidyverse)\nlibrary(tidybayes)\n```\n:::\n\n\n\nLet's begin just with a simulation of three interrelated traits:\n\n* when a bird arrives, which determines\n* how many eggs they lay, out of which there is \n* some number of surviving offspring\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## how many birds\nnbirds <- 57\n# simulate arrival dates -- two weeks before and after whatever the average is\ndarrive <- runif(nbirds, min = -14, max = 14) |> round()\n\n## simulate clutch sizes -- decrease by 4% each day\navg_clutch <- 4.5\neffect_per_day <- .97\n\nclutch <- rpois(nbirds, exp(log(avg_clutch) + log(effect_per_day)*darrive))\n\nplot(darrive, clutch)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\nAs an aside, this would be 0-truncated, since birds who don't lay eggs don't get observed at all.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# simulate hatching success\nsuccess <- rbinom(nbirds, size = clutch, prob = .86)\n\nplot(darrive, success)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nwhat's important to see here is that there is a negative correlation, even though the arrival date has no direct effect on the outcome\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(glm(success ~ darrive, family = \"poisson\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nglm(formula = success ~ darrive, family = \"poisson\")\n\nCoefficients:\n            Estimate Std. Error z value Pr(>|z|)    \n(Intercept)  1.31184    0.07081  18.526  < 2e-16 ***\ndarrive     -0.03306    0.00954  -3.466 0.000529 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for poisson family taken to be 1)\n\n    Null deviance: 76.946  on 56  degrees of freedom\nResidual deviance: 64.686  on 55  degrees of freedom\nAIC: 242.39\n\nNumber of Fisher Scoring iterations: 5\n```\n:::\n:::\n\n\n\nBut, if we use a binomial model that knows about the number of possible successful chicks, then we see what we expect: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nbin_mod <- (glm(cbind(success, clutch - success) ~ 1, family = binomial(link = \"logit\")))\n\nplogis(coef(bin_mod))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept) \n  0.8320896 \n```\n:::\n:::\n\n\nWhich matches the simulation above. \n\nif we put `darrive` in the model, the effect should be very close to 0 with overlap.\n\nIf we imagine that the laying date effects the survival p, then we should see an effect close to 0\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(glm(\n  cbind(success, clutch - success) ~ 1 + darrive,\n            family = binomial(link = \"logit\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nglm(formula = cbind(success, clutch - success) ~ 1 + darrive, \n    family = binomial(link = \"logit\"))\n\nCoefficients:\n            Estimate Std. Error z value Pr(>|z|)    \n(Intercept) 1.614447   0.175214   9.214   <2e-16 ***\ndarrive     0.005487   0.024064   0.228     0.82    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 67.636  on 56  degrees of freedom\nResidual deviance: 67.584  on 55  degrees of freedom\nAIC: 126.85\n\nNumber of Fisher Scoring iterations: 4\n```\n:::\n:::\n\n\nOne Stan model can model all of these at the same time\n\n\n::: {.cell}\n\n```{.r .cell-code}\none_indiv <- cmdstanr::cmdstan_model(\n  here::here(\"posts/2023-02-02-selection-on-plasticity/one_indiv.stan\"))\n\none_indiv\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\ndata{\n  int nbirds;\n  vector[nbirds] darrive;\n  array[nbirds] int clutch;\n  array[nbirds] int success;\n}\nparameters {\n  real logit_psuccess;\n  real log_avgclutch;\n  real log_b_date;\n}\nmodel {\n  success ~ binomial_logit(clutch, logit_psuccess);\n  clutch ~ poisson_log(log_avgclutch + log_b_date * darrive);\n  logit_psuccess ~ normal(1, .2);\n  log_avgclutch ~ normal(1, .2);\n  log_b_date ~ normal(0, .2);\n}\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\none_indiv_post <- one_indiv$sample(\n  data = list(nbirds = nbirds,\n              clutch = clutch, \n              success = success, \n              darrive = darrive))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 4 sequential chains...\n\nChain 1 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 1 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 1 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 1 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 1 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 1 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 1 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 1 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 1 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 1 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 1 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 1 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 1 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 1 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 1 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 1 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 1 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 1 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 1 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 1 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 1 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 1 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 1 finished in 0.1 seconds.\nChain 2 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 2 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 2 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 2 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 2 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 2 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 2 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 2 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 2 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 2 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 2 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 2 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 2 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 2 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 2 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 2 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 2 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 2 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 2 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 2 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 2 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 2 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 2 finished in 0.1 seconds.\nChain 3 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 3 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 3 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 3 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 3 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 3 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 3 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 3 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 3 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 3 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 3 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 3 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 3 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 3 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 3 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 3 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 3 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 3 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 3 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 3 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 3 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 3 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 3 finished in 0.1 seconds.\nChain 4 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 4 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 4 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 4 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 4 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 4 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 4 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 4 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 4 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 4 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 4 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 4 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 4 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 4 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 4 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 4 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 4 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 4 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 4 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 4 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 4 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 4 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 4 finished in 0.1 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.1 seconds.\nTotal execution time: 1.1 seconds.\n```\n:::\n\n```{.r .cell-code}\none_indiv_post\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       variable  mean median   sd  mad    q5   q95 rhat ess_bulk ess_tail\n lp__           26.28  26.59 1.21 1.00 23.90 27.61 1.00     2085     2932\n logit_psuccess  1.37   1.37 0.12 0.12  1.17  1.57 1.00     3348     3099\n log_avgclutch   1.44   1.44 0.06 0.06  1.34  1.54 1.00     2974     2772\n log_b_date     -0.04  -0.04 0.01 0.01 -0.05 -0.02 1.00     3251     2984\n```\n:::\n:::\n\n\nreasonably close to true values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplogis(1.44)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.8084547\n```\n:::\n\n```{.r .cell-code}\nlog(avg_clutch)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.504077\n```\n:::\n\n```{.r .cell-code}\nlog(effect_per_day)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.03045921\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsimulate_some_birds <- function(nbirds = 57, \n         log_b_date = log(.97),\n         log_avgclutch = log(4.5),\n         logit_psuccess = qlogis(.84)){\n  \n  # simulate arrival dates -- two weeks before and after whatever the average is\n  darrive <- runif(nbirds, min = -14, max = 14) |> round()\n  \n  ## simulate clutch sizes -- decrease  each day\n  clutch <- rpois(nbirds, exp(log_avgclutch + log_b_date*darrive))\n  \n  ## simulate success\n  success <- rbinom(nbirds, size = clutch, prob = plogis(logit_psuccess))\n  \n  return(list(\n    data_list = list(\n      nbirds = nbirds,\n      darrive = darrive, \n      clutch = clutch, \n      success = success \n    ),\n    true_values = tribble(\n      ~variable, ~true_value,\n      \"log_b_date\", log_b_date,\n      \"log_avgclutch\", log_avgclutch,\n      \"logit_psuccess\", logit_psuccess\n    )\n  ))\n}\n\n\ndata_for_simulation <- simulate_some_birds()\n\none_indiv_post <- one_indiv$sample(data = data_for_simulation$data_list,\n                                   refresh = 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 4 sequential chains...\n\nChain 1 finished in 0.1 seconds.\nChain 2 finished in 0.1 seconds.\nChain 3 finished in 0.1 seconds.\nChain 4 finished in 0.1 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.1 seconds.\nTotal execution time: 0.8 seconds.\n```\n:::\n\n```{.r .cell-code}\ncomparison <- one_indiv_post |> \n  # tidybayes::gather_rvars(logit_psuccess, log_avgclutch, log_b_date) |> \n  tidybayes::tidy_draws() |> tidybayes::gather_variables() |> \n  right_join(data_for_simulation$true_values, by = c(\".variable\" = \"variable\"))\n\n\ncomparison |> \n  ggplot(aes(y = .variable, x = .value)) + \n  stat_halfeye() + \n  geom_point(aes(y = variable, x = true_value),\n             col = \"orange\",\n             pch = \"|\",\n             size = 10, data = data_for_simulation$true_values)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n## No 0 birds\n\nThis system is a little challenging, since we never observe 0 eggs per bird -- if a bird cannot lay eggs (e.g. it does not find a nest spot) then it goes uncounted\n\nTo simulate this, I'll drop the 0 clutches before doing the rest of the simulations. This means that sample size will be less than or equal to the \"nbirds\" argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimulate_some_birds_nonzero <- function(nbirds = 57, \n         log_b_date = log(.97),\n         log_avgclutch = log(4.5),\n         logit_psuccess = qlogis(.84)){\n  \n  # simulate arrival dates -- two weeks before and after whatever the average is\n  darrive <- runif(nbirds, min = -14, max = 14) |> round()\n  \n  ## simulate clutch sizes -- decrease  each day\n  clutch <- rpois(nbirds, exp(log_avgclutch + log_b_date*darrive))\n  # drop 0 nests\n  nonzero_clutch <- which(clutch > 0)\n  \n  ## simulate success\n  success <- rbinom(nbirds, size = clutch, prob = plogis(logit_psuccess))\n  \n  return(list(\n    data_list = list(\n      nbirds = length(nonzero_clutch),\n      darrive = darrive[nonzero_clutch], \n      clutch  =  clutch[nonzero_clutch], \n      success = success[nonzero_clutch] \n    ),\n    true_values = tribble(\n      ~variable, ~true_value,\n      \"log_b_date\", log_b_date,\n      \"log_avgclutch\", log_avgclutch,\n      \"logit_psuccess\", logit_psuccess\n    )\n  ))\n}\n\nset.seed(1234)\nsome_nonzeros <- simulate_some_birds_nonzero(nbirds = 200)\n```\n:::\n\n\na plot to confirm that it works:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsome_nonzeros$data_list |> \n  as.data.frame() |> \n  ggplot(aes(x = darrive, y = clutch)) + geom_point()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nAnd fit the posterior\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_posterior_true <- function(simdata, stanmodel){\n  model_post <- stanmodel$sample(data = simdata$data_list,\n                                     refresh = 0, parallel_chains = 4)\n  \n  comparison <- model_post |> \n    tidybayes::tidy_draws() |> \n    tidybayes::gather_variables() |> \n    right_join(simdata$true_values, by = c(\".variable\" = \"variable\"))\n  \n  \n  comparison |> \n    ggplot(aes(y = .variable, x = .value)) + \n    stat_halfeye() + \n    geom_point(\n      aes(y = variable, x = true_value),\n      col = \"orange\",\n      pch = \"|\",\n      size = 10, data = simdata$true_values)\n}\n\n\nplot_posterior_true(some_nonzeros, one_indiv)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 4 parallel chains...\n\nChain 1 finished in 0.2 seconds.\nChain 2 finished in 0.2 seconds.\nChain 3 finished in 0.2 seconds.\nChain 4 finished in 0.2 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.2 seconds.\nTotal execution time: 0.4 seconds.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\nThere's already some bias happening! let's try what happens when the average is lower (and gives more 0s)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(420)\nsimulate_some_birds_nonzero(log_avgclutch = log(2.4),\n                            log_b_date = log(.7),\n                            nbirds = 300) |> \n  plot_posterior_true(one_indiv)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 4 parallel chains...\n\nChain 1 finished in 0.5 seconds.\nChain 2 finished in 0.5 seconds.\nChain 3 finished in 0.5 seconds.\nChain 4 finished in 0.5 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.5 seconds.\nTotal execution time: 0.8 seconds.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\nsome preliminary repetitions show that it usually misses either the average or the hatching success, frequently both. \n\n\n::: {.cell}\n\n```{.r .cell-code}\none_indiv_noZero <- cmdstanr::cmdstan_model(\n  here::here(\"posts/2023-02-02-selection-on-plasticity/one_indiv_noZero.stan\"))\n\none_indiv_noZero\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\ndata{\n  int nbirds;\n  vector[nbirds] darrive;\n  array[nbirds] int clutch;\n  array[nbirds] int success;\n}\nparameters {\n  real logit_psuccess;\n  real log_avgclutch;\n  real log_b_date;\n}\nmodel {\n  vector[nbirds] alpha = log_avgclutch + log_b_date * darrive;\n  success ~ binomial_logit(clutch, logit_psuccess);\n  logit_psuccess ~ normal(1, .2);\n  log_avgclutch ~ normal(1, .2);\n  log_b_date ~ normal(0, .2);\n  clutch ~ poisson_log(alpha);\n  // no zeros -- this normalizes the poisson density for a 0-truncated variable\n  target += -log1m_exp(-exp(alpha));\n}\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(420)\nsimulate_some_birds_nonzero(log_avgclutch = log(4.4),\n                            log_b_date = log(.9),\n                            nbirds = 300) |> \n  plot_posterior_true(one_indiv_noZero)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 4 parallel chains...\n\nChain 1 finished in 1.5 seconds.\nChain 2 finished in 1.5 seconds.\nChain 3 finished in 1.5 seconds.\nChain 4 finished in 1.5 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 1.5 seconds.\nTotal execution time: 1.6 seconds.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n### Truncating using a different syntax\n\nThe manual [uses a different syntax](https://mc-stan.org/docs/stan-users-guide/truncated-data.html). \nTo write the equation above this way, I found I needed to make a few changes:\n\n* `poisson_log` has to be replaced with `poisson` and the `exp()` link function\n\n... that was actually the only change. \nIt runs at the same speed as the previous way of writing it, and gets the same answer:\n\n\n::: {.cell}\n\n```{.r .cell-code}\none_indiv_zerotrunc <- cmdstanr::cmdstan_model(\n  here::here(\"posts/2023-02-02-selection-on-plasticity/one_indiv_zerotrunc.stan\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nIn file included from stan/src/stan/model/model_header.hpp:11:\nstan/src/stan/model/model_base_crtp.hpp:198: warning: 'void stan::model::model_base_crtp<M>::write_array(boost::random::ecuyer1988&, std::vector<double, std::allocator<double> >&, std::vector<int>&, std::vector<double, std::allocator<double> >&, bool, bool, std::ostream*) const [with M = one_indiv_zerotrunc_model_namespace::one_indiv_zerotrunc_model; boost::random::ecuyer1988 = boost::random::additive_combine_engine<boost::random::linear_congruential_engine<unsigned int, 40014, 0, 2147483563>, boost::random::linear_congruential_engine<unsigned int, 40692, 0, 2147483399> >; std::ostream = std::basic_ostream<char>]' was hidden [-Woverloaded-virtual=]\n  198 |   void write_array(boost::ecuyer1988& rng, std::vector<double>& theta,\n      | \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nC:/Users/UTILIS~1/AppData/Local/Temp/RtmpGIFFTA/model-3d7072fc3aac.hpp:369: note:   by 'one_indiv_zerotrunc_model_namespace::one_indiv_zerotrunc_model::write_array'\n  369 |   write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&\n      | \nstan/src/stan/model/model_base_crtp.hpp:136: warning: 'void stan::model::model_base_crtp<M>::write_array(boost::random::ecuyer1988&, Eigen::VectorXd&, Eigen::VectorXd&, bool, bool, std::ostream*) const [with M = one_indiv_zerotrunc_model_namespace::one_indiv_zerotrunc_model; boost::random::ecuyer1988 = boost::random::additive_combine_engine<boost::random::linear_congruential_engine<unsigned int, 40014, 0, 2147483563>, boost::random::linear_congruential_engine<unsigned int, 40692, 0, 2147483399> >; Eigen::VectorXd = Eigen::Matrix<double, -1, 1>; std::ostream = std::basic_ostream<char>]' was hidden [-Woverloaded-virtual=]\n  136 |   void write_array(boost::ecuyer1988& rng, Eigen::VectorXd& theta,\n      | \nC:/Users/UTILIS~1/AppData/Local/Temp/RtmpGIFFTA/model-3d7072fc3aac.hpp:369: note:   by 'one_indiv_zerotrunc_model_namespace::one_indiv_zerotrunc_model::write_array'\n  369 |   write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&\n      | \n```\n:::\n\n```{.r .cell-code}\none_indiv_zerotrunc\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\ndata{\n  int nbirds;\n  vector[nbirds] darrive;\n  array[nbirds] int clutch;\n  array[nbirds] int success;\n}\nparameters {\n  real logit_psuccess;\n  real log_avgclutch;\n  real log_b_date;\n}\nmodel {\n  success ~ binomial_logit(clutch, logit_psuccess);\n  logit_psuccess ~ normal(1, .2);\n  log_avgclutch ~ normal(1, .2);\n  log_b_date ~ normal(0, .2);\n  vector[nbirds] alpha = log_avgclutch + log_b_date * darrive;\n  clutch ~ poisson(exp(alpha)) T[1,];\n}\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(420)\nsimulate_some_birds_nonzero(log_avgclutch = log(4.4),\n                            log_b_date = log(.9),\n                            nbirds = 300) |> \n  plot_posterior_true(one_indiv_zerotrunc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 4 parallel chains...\n\nChain 2 finished in 2.0 seconds.\nChain 3 finished in 2.0 seconds.\nChain 1 finished in 2.1 seconds.\nChain 4 finished in 2.0 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 2.0 seconds.\nTotal execution time: 2.2 seconds.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n:::{.callout-note}\n# Two parameterizations diverged in a yellow wood\nThese two ways of writing the model both work. Which to choose? \nWell, I was pleased with myself for manually normalizing the Poisson likelihood in the first model. \nHowever the second is clearer to the reader. In the first, it takes two lines of code -- not even necessarily next to each other. In the second, the big `T` for *T*runcation indicates clearly what is going on. Code is communication; clarity wins.\n:::\n\n### Zero inflated binomial success\n\nOnce in a while, a nest will just be completely destroyed by, say, a predator. \nThis has nothing to do with anything, probably, and is just a catastrophic Act of Weasel. \nLet's imagine that some small proportion of the nests just die:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimulate_some_birds_nonzero_zeroinflated <- function(nbirds = 57, \n         log_b_date = log(.97),\n         log_avgclutch = log(4.5),\n         logit_psuccess = qlogis(.84),\n         logit_pfail = qlogis(.1)){\n  \n  # simulate arrival dates -- two weeks before and after whatever the average is\n  darrive <- runif(nbirds, min = -14, max = 14) |> round()\n  \n  ## simulate clutch sizes -- decrease  each day\n  clutch <- rpois(nbirds, exp(log_avgclutch + log_b_date*darrive))\n  # drop 0 nests\n  nonzero_clutch <- which(clutch > 0)\n  n_laid <- length(nonzero_clutch)\n  \n  # simulate success -- among birds which laid at least 1 egg, there is a chance of failing completely\n  success_among_nonzero <- rbinom(n_laid,\n                                  size = clutch[nonzero_clutch],\n                                  prob = plogis(logit_psuccess))\n  failed_nests <- rbinom(n_laid, size = 1, prob = plogis(logit_pfail))\n\n  success_zi <- success_among_nonzero * (1 - failed_nests)\n  \n  # success <- rbinom(nbirds, \n  #                   size = clutch,\n  #                   prob = plogis(logit_psuccess))\n  # failed_nests <- rbinom(nbirds, size = 1, prob = plogis(logit_pfail))\n  # \n  # success_zi <- success * (1 - failed_nests)\n  \n  return(list(\n    data_list = list(\n      nbirds = n_laid,\n      darrive = darrive[nonzero_clutch], \n      clutch  =  clutch[nonzero_clutch], \n      success = success_zi#[nonzero_clutch]\n    ),\n    true_values = tribble(\n      ~variable, ~true_value,\n      \"log_b_date\", log_b_date,\n      \"log_avgclutch\", log_avgclutch,\n      \"logit_psuccess\", logit_psuccess,\n      \"logit_pfail\", logit_pfail\n    )\n  ))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\none_indiv_ztrunc_zinf <- cmdstanr::cmdstan_model(\n  here::here(\"posts/2023-02-02-selection-on-plasticity/one_indiv_ztrunc_zinf.stan\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nIn file included from stan/src/stan/model/model_header.hpp:11:\nstan/src/stan/model/model_base_crtp.hpp:198: warning: 'void stan::model::model_base_crtp<M>::write_array(boost::random::ecuyer1988&, std::vector<double, std::allocator<double> >&, std::vector<int>&, std::vector<double, std::allocator<double> >&, bool, bool, std::ostream*) const [with M = one_indiv_ztrunc_zinf_model_namespace::one_indiv_ztrunc_zinf_model; boost::random::ecuyer1988 = boost::random::additive_combine_engine<boost::random::linear_congruential_engine<unsigned int, 40014, 0, 2147483563>, boost::random::linear_congruential_engine<unsigned int, 40692, 0, 2147483399> >; std::ostream = std::basic_ostream<char>]' was hidden [-Woverloaded-virtual=]\n  198 |   void write_array(boost::ecuyer1988& rng, std::vector<double>& theta,\n      | \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nC:/Users/UTILIS~1/AppData/Local/Temp/RtmpGIFFTA/model-3d7077b0200d.hpp:420: note:   by 'one_indiv_ztrunc_zinf_model_namespace::one_indiv_ztrunc_zinf_model::write_array'\n  420 |   write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&\n      | \nstan/src/stan/model/model_base_crtp.hpp:136: warning: 'void stan::model::model_base_crtp<M>::write_array(boost::random::ecuyer1988&, Eigen::VectorXd&, Eigen::VectorXd&, bool, bool, std::ostream*) const [with M = one_indiv_ztrunc_zinf_model_namespace::one_indiv_ztrunc_zinf_model; boost::random::ecuyer1988 = boost::random::additive_combine_engine<boost::random::linear_congruential_engine<unsigned int, 40014, 0, 2147483563>, boost::random::linear_congruential_engine<unsigned int, 40692, 0, 2147483399> >; Eigen::VectorXd = Eigen::Matrix<double, -1, 1>; std::ostream = std::basic_ostream<char>]' was hidden [-Woverloaded-virtual=]\n  136 |   void write_array(boost::ecuyer1988& rng, Eigen::VectorXd& theta,\n      | \nC:/Users/UTILIS~1/AppData/Local/Temp/RtmpGIFFTA/model-3d7077b0200d.hpp:420: note:   by 'one_indiv_ztrunc_zinf_model_namespace::one_indiv_ztrunc_zinf_model::write_array'\n  420 |   write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&\n      | \n```\n:::\n\n```{.r .cell-code}\none_indiv_ztrunc_zinf\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\ndata{\n  int nbirds;\n  vector[nbirds] darrive;\n  array[nbirds] int clutch;\n  array[nbirds] int success;\n}\nparameters {\n  real logit_psuccess;\n  real log_avgclutch;\n  real log_b_date;\n  real logit_pfail;\n}\nmodel {\n  logit_pfail ~ normal(-1, .5);\n  logit_psuccess ~ normal(1, .2);\n  log_avgclutch ~ normal(1, .2);\n  log_b_date ~ normal(0, .2);\n\n  // Eggs laid -- at least one\n  vector[nbirds] alpha = log_avgclutch + log_b_date * darrive;\n  clutch ~ poisson(exp(alpha)) T[1,];\n\n  // nestling success\n  for (n in 1:nbirds) {\n    if (success[n] == 0) {\n      target += log_sum_exp(\n        log_inv_logit(logit_pfail),\n        log1m_inv_logit(logit_pfail) + binomial_logit_lpmf(0 | clutch[n], logit_psuccess)\n        );\n    } else {\n      target += log1m_inv_logit(logit_pfail) + binomial_logit_lpmf(success[n] | clutch[n], logit_psuccess);\n    }\n  }\n\n}\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(477)\nsome_zi_birds <- simulate_some_birds_nonzero_zeroinflated(log_avgclutch = log(4.4),\n                            log_b_date = log(.9),\n                            nbirds = 300) \n\nsome_zi_birds|> \n  plot_posterior_true(one_indiv_ztrunc_zinf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 4 parallel chains...\n\nChain 1 finished in 4.7 seconds.\nChain 4 finished in 4.8 seconds.\nChain 2 finished in 5.0 seconds.\nChain 3 finished in 5.2 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 4.9 seconds.\nTotal execution time: 5.3 seconds.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\nI initially failed to recover the parameter for `logit_pfail`. Here I some things I learned: \n\n* Simulating zero-inflated numbers can be tricky! I flipped back and forth between simulating 0-inflation for all nests, and simulating for only those with at least 1 egg. In retrospect, it is clear that these are equivalent. There are two independent things here: the probability of a clutch having 0 eggs and the probability of a 0 coming from the zero-inflated binomial. \n* this zero-inflated model is quite _sensitive to the prior_. That's because there are not very many zeros being inflated: in my simulation at least, failed nests are rare and success is naturally low. it would be pretty important to decide in advance if sudden nest failure (e.g. by predation) is rare or common\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}